系统函数:
    由系统提供的函数称为原函数或原语--因为其他一切都是建立在这些函数之上的
    设想一个绘制图形化用户界面的程序:必须有一个函数创建菜单,该函数可能还调用
    其它函数写入文字或图标,描绘背景,计算鼠标指针的位置等等
    但是最终都会用到一组由系统提供的原语,用来绘制点和线

函数的组成部分及工作原理:
    函数名:
        函数名是一个符号,代表该函数代码的起始地址
        在汇编中,符号是通过在函数代码前输入函数名作为标签来定义的,如跳转标签
    函数参数:
        函数参数也可以用于存放指针,指针指向函数要传回程序的数据
    局部变量:
        局部变量是函数在进行处理过程中使用的数据存储区,在函数返回时废弃
    静态变量:
        静态变量也是函数在进行处理过程中使用的数据存储区,在函数返回时保留
        每当代码被激活时都重复使用,程序的任何其他部分都无法访问此数据
    全局变量:
        全局变量是函数进行处理时用到的,在函数之外管理的数据存储区
    返回地址:
        返回地址是一个看不见的参数,因为不能直接在函数中使用
        返回地址告诉函数当其执行完后应该再从哪里执行
        在大多数编程语言中,调用函数会自动传递这个参数
        在汇编语言中,call指令会为你处理返回地址
                    ret指令负责按照改地址返回调用函数的地方
    返回值:
        返回值是传回数据到主程序的主要方法

调用约定:
    在不同语言中,变量存储以及计算机传输参数和返回值的方式各不相同,这种差异称为语言的调用约定
    汇编语言能使用其偏好的任何调用约定,甚至可以自己定一个调用约定
    但是如果想与其他语言编写的函数进行互动,必须服从其他语言的调用约定

栈:
    栈寄存器%esp总是包含一个指向当前栈顶的指针,无论栈顶在何处
    每当用pushl将数据入栈,%esp所包含的指针值都会减去4,从而指向新的栈顶,栈是向下生长的
    每当用popl将数据出栈,%esp所包含的指针值都会加上4,从而指向新的栈顶,并将先前栈顶的值放入你指定的寄存器
    访问栈顶的值,使用间接寻址即可movl (%esp),%eax
    movl %esp,%eax  那么%eax会保存指向栈顶的指针,而不是栈顶存放的值
    将%esp置于括号中将会使计算机遵循间接寻址方式,因而获得%esp所含指针指向的值
    movl 4(%esp),%eax   访问栈顶的下一个值(基址寻址)
    在C语言的调用约定中,栈是实现函数的局部变量和参数以及返回地址的关键因素

函数执行过程中的栈:
    在执行函数前,一个程序将函数的所有参数按逆序压人栈中,接着发出一条call指令
    表明程序希望开始执行哪一个函数
    call指令会做两件事:
        1.将下一条指令的地址及返回地址压人栈中
        2.修改指令指针%eip指向函数起始处
    函数开始执行时的栈:
        参数#N
        ......
        参数3
        参数2
        参数1
        返回地址    <----(%esp)栈顶指针
    函数的每个参数都已被压人栈中,最后入栈的是返回地址
    现在函数本身也有一些工作要做:
        1.首先,函数通过pushl %ebp指令保存当前的基址指针寄存器%ebp
            基址指针寄存器%ebp是一个特殊的寄存器,用于访问函数的参数和局部变量
        2.其次,函数通过movl %esp,%ebp,将栈指针%ebp复制到%esp
            使你能够把函数参数作为相对于基址指针的固定索引进行访问
            你也许认为可以使用栈指针来访问函数参数,但在程序中你可能会对栈进行操作
    在函数开始时将栈指针复制到基址指针寄存器可以让你清楚参数的位置,即使在将其他数据压人弹出栈的情况下也是如此
    %ebp将一直是栈指针在函数开始时的位置,所以可以说是对栈帧的常量引用
    栈帧包含一个函数中使用的所有栈变量,包括参数和局部变量以及返回地址
    此时的栈:
        参数#N  <----N*4+4(%ebp)基址指针寄存器
        ......
        参数3   <----16(%ebp)
        参数2   <----12(%ebp)
        参数1   <----8(%ebp)
        返回地址 <----4(%ebp)
        旧%ebp  <----(%esp栈顶指针寄存器)和(%ebp基址指针寄存器)
    可以看出每个参数都可以用%ebp通过基址寻址方式访问
    接下来函数为其所需的所有局部变量保留栈空间,只需将栈指针向外移动即可实现
    假设要运行函数,我们需要两个字的内存,只需将栈指针向下移动两个字即可预留空间,栈是向下生长的
    这是通过如下指令实现的:
        subl $8,%esp    $表示立即寻址
    该指令将%esp减去8,这样就能将栈用于变量存储
    无需担心函数调用引起的入栈会破坏存储的变量
    因为函数调用是在栈帧上分配的,而变量仅仅在函数运行期间有效
    当函数返回时,栈帧就不复存在,这些变量也不复存在,这就是局部变量
    现在我们有两个字可用于本地存储
    此时的栈:
        参数#N  <----N*4+4(%ebp)基址指针寄存器
        ......
        参数3   <----16(%ebp)
        参数2   <----12(%ebp)
        参数1   <----8(%ebp)
        返回地址 <----4(%ebp)
        旧%ebp   <----(%ebp)
        局部变量1<----  -4(%ebp)
        局部变量2<----  -8(%ebp)和(%esp)
    所以我们可以使用%ebp中不同的偏移量,通过基址寻址方式访问这个函数所需的所有数据
    所以%ebp被称为基址指针,可以在基址指针寻址方式中使用其他寄存器,但在x86架构中,使用%ebp会更快
    访问全局变量和静态变量就像之前访问内存一样
    全局变量和静态变量之间的唯一区别就是静态变量只能用于一个函数
    而全局变量可以由许多函数共同使用,虽然汇编语言一视同仁,但大多数语言会区分
    当一个函数执行完后,函数会做三件事:
        1.将返回值存储到%eax
        2.将栈恢复到调用函数时的状态(移除当前栈帧,并使调用代码的栈帧重新生效)
        3.将控制权交还给调用它的程序,这是通过ret指令实现的
            ret指令将栈顶的值弹出,并将指令指针%eip设置为该弹出值
    所以在函数将控制权返回调用它的代码时,必须恢复前一个栈帧,如若不然,ret指令无法正常工作
    因为我们当前栈帧的返回地址不在栈顶
    因此返回前必须将栈指针%esp和基址指针%ebp重新设置为函数开始时的值
    所以要从函数返回,必须使用如下指令:
        movl %ebp,%esp
        popl %ebp
        ret
    此刻将所有局部变量视为废弃,原因是在你移动栈指针后入栈的数据很可能覆盖之前存放的内容
    因此不应该在创建局部变量的函数的声明周期后,还保留该局部变量的地址
    至此将控制权转回到调用代码那,调用代码现在可以检查%eax中的返回值
    调用代码也需要弹出其入栈的所有参数以将栈指针复位到原先的位置(如无需参数值,使用addl指令将"4*参数个数"加到%esp即可)
