寻址方式说明
内存地址引用的通用格式如下:
地址或偏移(%基址寄存器,%索引寄存器,比例因子)
所有字段都是可选的,如果省略将以0替代,地址或偏移以及比例因子必须是常量,其余两个必须是寄存器
结果地址=地址或偏移+%基址或偏移量寄存器+索引寄存器*比例因子

直接寻址方式:
这种模式使用地址或偏移以及%索引寄存器实现,可以将任何通用寄存器作为索引寄存器
movl data_items(,%edi,4), %eax  #加载数据的第一个字节,汇编中使用的索引寻址movl 起始地址(,%索引寄存器,字长)4其实是比例因子,从data_items开始递增%edi*4个位置

间接寻址方式:
从寄存器指定的地址处加载值
movl (%eax),%ebx                #加载%eax中保存的地址位置的值到%ebx

基址寻址方式:
基址寻址方式与间接寻址方式类似,不同之处在于基址寻址将一个常量值与寄存器中的地址相加
movl 4(%eax),%ebx               #起始地址在%eax中,提取起始地址后4字节的内容到%ebx

立即寻址方式:
用于直接将值加载到寄存器或存储位置
movl $12,%eax                   #加载数字12到%eax

寄存器寻址方式:
寄存器寻址方式仅仅是将数据移入或移出寄存器

感觉李忠的归纳较好
x86汇编语言:从实模式到保护模式的寻址方式总结第七章7.7
寄存器寻址:
    最简单的寻址方式,指令执行时,操作数位于寄存器中
        mov ax,bx
        inc dx
        add bx,0xf000 目的操作数是寄存器

立即寻址:
    也就是立即数寻址,指令的操作数是一个立即数
        add bx,0xf000   目的操作数使用寄存器寻址,源操作数使用立即数
        mov dx,label_a  目的操作数使用寄存器寻址,源操作数使用立即数,标号代表一个汇编地址,编译时转换成立即数

内存寻址:实际上就是寻找偏移地址,称为有效地址
    1.直接寻址
        使用该寻址方式的操作数是一个偏移地址,而且给出了该偏移地址的具体数值
            mov ax,[0x5c0f]             源操作数使用直接寻址,指令执行时,处理器将数据段寄存器ds左移4位,加上这里的0x5c0f得到20位的物理地址,接着从该物理地址取得一个字传送到ax(ax16位))
            add word [0x0230],0x5000    目的操作数使用直接寻址,处理器将数据段寄存器ds左移4位,加上这里的0x0230得到20位的物理地址,并将立即数0x5000加到这个单元
            xor byte [es:label_a],0x05  目的操作数使用直接寻址,使用超越段前缀只是用来改变默认的数据段
            但凡表示内存地址的使用[]
    2.基址寻址
        很多时候,数据紧挨在一起,顺序存放
            buffer dw 0x20,0x100,0x0f,0x300,0xff00
        使用直接寻址是这样的
            inc word [buffer]
            inc word [buffer+2]
            inc word [buffer+4]
            ......
        考虑到效率和代码简洁,可使用基址寻址,就是在指令的地址部分使用基址寄存器bx或bp来提供偏移地址
            mov [bx],dx         目的操作数使用基址寻址,指令执行时,处理器将数据段寄存器ds左移4位,加上基址寄存器bx中的内容,形成20位物理地址,然后将dx中的内容传送到该地址单元
            add byte [bx],0x55  目的操作数使用基址寻址,指令执行时,处理器将数据段寄存器ds左移4位,加上基址寄存器bx中的内容,形成20位物理地址,然后将指令中的立即数0x55加到该地址处的字节单元中
        使用基址寻址可以使得代码变得简洁高效
            mov bx,buffer
            mov cx,4
        lpinc:
            inc word [bx]
            add bx,2
            loop lpinc
        基址寄存器也可以是bp
            mov ax,[bp] 源操作数使用基址寻址方式,特殊在于使用基址寄存器bp,在形成20位物理地址时,默认的段寄存器是ss,多用于访问栈
        栈的限制
            mov ax,,0x5000
            push ax
            mov ax,0x7000
            push ax
        显然要用pop指令弹出数据就必须先弹出0x7000再弹出0x5000,除非改变sp
        有时候希望在不破坏栈的情况下越过限制访问栈中的内容,特别是sp,是的push和pop正常进行
        典型的例子是高级语言里的函数调用,所有的参数都位于栈中,为了能访问压在栈底的参数,这时bp就派上用场
            mov ax,,0x5000
            push ax
            mov bp,sp
            mov ax,0x7000
            push ax
            mov dx,[bp] ;dx中为0x5000
        基址寻址允许在基址寄存器的基础上使用一个偏移量
            mov dx,[bp-2] 指令执行时,处理器将栈段寄存器ss左移4位,加上基址寄存器bp中的内容,再减去偏移量2,形成20位物理地址,其中bp中的内容在指令执行后不改变
        这种方式也适用于基址寄存器bx
            mov bx,buffer           xor bx,bx
            mov cx,4                mov cx,4
        lpinc:                  lpinc:
            inc word [bx]           inc word [bx+buffer]    相加操作仅用于形成有效偏移地址,不改变bx
            add bx,2                add bx,2
            loop lpinc              loop lpinc
        第二个代码是批量加一任务的新版本,区别仅仅在于,bx现在是从0开始递增的
    3.变址寻址
        变址寻址类似于基址寻址,唯一不同之处在于使用的是变址寄存器或称为索引寄存器的寄存器si和di
            mov [si],dx
            add ax,[di]
            xor word [si],0x8000
        和基址寻址一样,当带有这种操作数的指令执行时,处理器会使用ds指向的数据段,并由si或di提供偏移地址,,除非使用超越段前缀
        和基址寻址一样变址寻址也允许带一个偏移量
            mov [si+0x100],al
            and byte [di+label_a],0x80
    4.基址变址寻址
        设有数据串
            string db 'abcdefghijklmnopqrstuvwxyz'
        原地反向排列(26个数据压栈后反序出栈)
            mov cx,26
            mov bx,string
        lppush:
            mov al,[bx]
            push ax
            inc bx
            loop lppush     循环压栈

            mov cx,26
            mov bx,string
        lppop:
            pop ax
            mov [bx],al
            inc bx
            loop lppop      循环出栈
        以上是一个办法,不过8086处理器支持一种基址加变址的寻址方式,也就是基址变址寻址,操作数可以使用一个基址寄存器(bx或bp),外加一个变址寄存器(si或di)
            mov ax,[bx+si]              源操作数使用基址变址寻址,指令执行时,处理器将数据段寄存器ds左移4位,加上基址寄存器bx中的内容,再加上变址寄存器si中的内容,形成20位物理地址,从该地址处取得一个字传送到ax中
            add word [bx+di],0x3000     目的操作数使用基址变址寻址,源操作数使用立即寻址,指令执行时,处理器将数据段寄存器ds左移4位,加上基址寄存器bx中的内容,再加上变址寄存器di中的内容,形成20位物理地址,然后将立即数0x3000加到改地址处的字单元中
        采用基址变址寻址方式的反向排列代码
            mov bx,string   数据区首地址
            mov si,0        正向索引
            mov di,25       反向索引
        order:
            mov ah,[bx+si]
            mov al,[bx+di]
            mov [bx+si],al
            mov [bx+di],ah  以上4行用于交换首尾数据
            inc si
            dec di
            cmp si,di
            jl order        首尾没有相遇或者没有超越则继续
        同样地,基址变址寻址允许在基址寄存器和变址寄存器的基础上带一个偏移量
            mov [bx+si+0x100],al
            and byte [bx+di+label_a],0x80