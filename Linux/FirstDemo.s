#目的:退出并向linux内核返回一个状态码
#输入:无
#输出:返回一个状态码,在运行程序后可通过输入echo $?来读取状态码
#变量:
#   %eax保存系统调用号
#   %ebx保存返回状态
#
#
.section .data
.section .text
.globl _start
_start:
movl $1,%eax    #用于退出程序的linux内核命令号(系统调用)
movl $0,%ebx    #返回操作系统的状态码
int $0x80       #唤醒内核以运行退出命令,实际上将控制权交给中断号设立的中断处理程序
########################################
#在汇编程序中,任何以小数点开头的指令都不会被字节翻译成机器指令
#这些针对汇编程序本身的指令,是由汇编程序处理,实际上并不会由计算机执行,所以称为汇编指令或伪操作
#.section指令将程序分成几个部分,.section .data命令是数据段的开始
#数据段中要列出程序数据所需要的所有内存存储空间
#由于程序中没有使用任何数据,所以不需要这个段,为保持程序完整性保留该指令
#.section .text表示文本段的开始,文本段是存放程序指令的部分
#.globl _start这条指令指示汇编程序:_start很重要,必须记住
#_start是个符号,也就是说它将在汇编或链接过程中被其他内容替换
#符号一般用来标记程序或数据的位置,所以可以用名字而非内存位置编号指代它们
#试想以下通过地址指代每个内存位置将会令人困惑,必须记住或查找每一行代码或数据的数字内存地址
#每次插入数据或代码,必须更改所有地址
#.globl表示汇编程序不应该在会汇编之后废弃这个符号,因为连接器需要它
#_start是个特殊符号,总是用.globl来标记,因为它标记了该程序的开始位置
#_start:定义_start标签的值,标签是一个符号,后面跟一个冒号,标签定义一个符号的值
#当汇编程序进行汇编时,必须为每个数值每条指令分配地址,标签告诉汇编程序以该符号的值作为下一条指令或下一个数据元素的位置
#这样,如果数据或指令的实际物理位置更改,也无需重写引用,符号会自动获取新值
#movl $1,%eax将数字1移入%eax寄存器,数字前$表示使用立即寻址方式寻址,如果没有美元符号,指令会进行直接寻址,加载地址1中的数字
#movl有两个操作数,源操作数和目的操作数
#操作数可以是数字/内存位置引用/寄存器
#大多数指令有两个操作数,在这种情况下,源操作数不会改变
#将源操作数与目的操作数相加/相减/相乘,将结果存放到目的操作数
#x86通用寄存器:
#%eax
#%ebx
#%ecx
#%edx
#%edi
#%esi
#x86专用寄存器:
#%ebp
#%esp
#%eip
#eflags
#寄存器以e开头是因为早期x86处理器是16位而非32位,保留旧名以引用寄存器的前半部分,加e开头引用32位寄存器
#%rax是64位寄存器
#将数字1移入%eax是因为我们准备调用linux内核,数字1表示系统调用exit
#正常的程序并非无所不能,许多操作如调用其他程序/处理文件/退出等必须通过系统调用由操作系统处理
#在进行系统调用时必须将系统调用号加载到%eax,且不同的系统调用可能要求其他寄存器也必须含有值
#系统调用并非寄存器的唯一或主要用途,只是在当前程序的一种用途
#除了知道进行哪个调用,操作系统通常需要更多信息,例如在处理文件时,需要知道你在处理那个文件
#想写什么数据等,这些额外信息称为参数,存储在其他寄存器中
#在进行系统调用exit的情况下,操作系统需要将状态码加载到%ebx,稍后这个值将返回给系统,就是键入echo $?是提取的值
#但是将这些数字加载到寄存器本身不会做任何事,系统调用之外的事务也需要用到寄存器
#linux只需要在系统调用时将某些参数值加载到某些寄存器,不同系统调用有不同的要求
#就系统调用exit而言,要求将退出状态加载到%ebx
#int $0x80 int代表中断,0x80是要用到的中断号,中断会中断正常的程序流,将控制权从程序转移到linux
#实际上中断将控制权转移到为中断号设立中断处理的程序,这些由linux内核处理
#操作系统的功能是通过系统调用来访问的,这是通过以特殊方式设置寄存器并发出int $0x80指令调用的
