         ;代码清单11-1
         ;文件名：c11_mbr.asm
         ;文件说明：硬盘主引导扇区代码 
         ;创建日期：2011-5-16 19:54

         ;设置堆栈段和栈指针
         mov ax,cs      
         mov ss,ax                          ;使栈段的逻辑段和代码段相同
         mov sp,0x7c00                      ;栈指针指向0x7c00,这是个分界线,代码段向上扩展,栈段向下扩展
;至此还处于实模式,因此在GDT中安装描述符时必须将GDT的线性地址(物理地址)转换成逻辑段地址和偏移地址
         ;计算GDT所在的逻辑段地址 
         mov ax,[cs:gdt_base+0x7c00]        ;低16位,因为主引导扇区的实际加载位置是0x0000:0x7c00,所以标号gdt_base处的偏移地址是gdt_base+0x7c00
         mov dx,[cs:gdt_base+0x7c00+0x02]   ;高16位 
         mov bx,16    
         div bx                             ;将DX:AX除以16,得到的商ax是逻辑段地址,余数dx是偏移地址
         mov ds,ax                          ;令DS指向GDT所在段以进行操作
         mov bx,dx                          ;GDT所在段的段内起始偏移地址
;处理器规定GDT中的第一个描述符必须是空描述符,或者叫哑描述符或NULL描述符,很多时候寄存器和内存单元的初始值会为0,再加上程序设计有问题,就会在无意中用全0的索引来选择描述符,因此处理器要求第一个描述符定义成空描述符      
         ;创建0#描述符，它是空描述符，这是处理器的要求,该描述符槽位号是0,处理器不允许访问这个描述符,任何时候使用索引字段为0的选择子来访问该描述符都会被处理器阻止,并引发异常中断
         mov dword [bx+0x00],0x00           ;全0的双字写入,32位0
         mov dword [bx+0x04],0x00           ;全0的双字写入,32位0
;进入保护模式之后必然要从一个代码段开始执行,开始定义代码段描述符
         ;创建#1描述符，保护模式下的代码段描述符,该段(该段就是正在执行的主引导程序所在区域)的基本情况是:线性基地址为0x00007C00,段界限为0x001FF(20位),粒度为字节(G=0),该段长度为512字节,属于存储器的段(S=1),这是一个32位的段(D=1),该段位于内存中(P=1),特权级为0(DPL=00),只能执行(TYPE=1000)
         mov dword [bx+0x08],0x7c0001ff     ;低32位0111 1100 0000 0000 0000 0001 1111 1111
         mov dword [bx+0x0c],0x00409800     ;高32位0000 0000 0100 0000 1001 1000 0000 0000
;数据段的基本情况:线性基地址为0x000B8000(显存的起始地址),段界限为0x0FFFF(20位),粒度为字节(G=0),该段长度为64KB,属于存储器的段(S=1),这是一个32位的段(D=1),该段位于内存中(P=1),特权级为0(DPL=00),可读可写,向上扩展的数据段(TYPE=0010)
         ;创建#2描述符，保护模式下的数据段描述符（文本模式下的显示缓冲区）
         mov dword [bx+0x10],0x8000ffff
         mov dword [bx+0x14],0x0040920b
;栈段的基本情况:线性基地址为0x00000000,段界限为0x07A00(20位),粒度为字节(G=0),属于存储器的段(S=1),这是一个32位的段(D=1),该段位于内存中(P=1),特权级为0(DPL=00),可读可写,向下扩展的数据段,在这里是栈段(TYPE=0010)
         ;创建#3描述符，保护模式下的堆栈段描述符,在这里,段界限的值0x07A00加上1(0x07A01)就是ESP寄存器允许的最小值,当执行push,call等隐式操作时,处理器会检查ESP的值,小于等于这里的数值会引发异常中断
         mov dword [bx+0x18],0x00007a00
         mov dword [bx+0x1c],0x00409600
;至此所有描述符安装完毕,接下来加载描述符表的线性基地址和界限到描述符表寄存器GDTR
         ;初始化描述符表寄存器GDTR
         mov word [cs: gdt_size+0x7c00],31  ;描述符表的界限值31（总共4个描述符,每个描述符8个字节,界限值等于总字节数减一）写入标号gdt_size的内存单元中   
;把标号gdt_size开始的6字节加载到GDTR寄存器,到目前为止依然工作在实模式下,lgdt指令的操作数是一个48位6字节的内存区域,在16位模式下,该地址是16位的,在32位模式下,该地址是32位的,实模式和保护模式下均可执行,且不影响任何标志位
         lgdt [cs: gdt_size+0x7c00]         ;因为gdt_size和gdt_base是连续声明的,所以从gdt_size处读取6字节就包括了gdt_base
;在这6字节的内存区域中,要求前16位是GDT的界限值,后32位是GDT的基地址,在初始状态下,GDTR的基地址被初始化为0x0000 0000,界限值为0xFFFF
         in al,0x92                         ;将南桥芯片内的0x92端口内容读入al
         or al,0000_0010B                   ;将第2位置1再写回0x92端口,这样就打开A20
         out 0x92,al                        ;打开A20
;保护模式下的中断机制和实模式不同,原有的中断向量表不再适用,在保护模式下,BIOS中断都不能再用,因为它们是实模式下的代码,再重新设置保护模式下的中断环境之前,必须关闭中断
         cli                                ;保护模式下中断机制尚未建立，应
                                            ;禁止中断 
         mov eax,cr0                        ;将CR0的原有内容传送到EAX,以准备修改
         or eax,1                           ;将第1位置1,其余保持不变
         mov cr0,eax                        ;设置PE位为1,将直接导致处理器的运行模式变成保护模式,CR0是处理器内部的32位控制寄存器,它的第1位是保护模式允许位(Protection Enable),该位置1,则进入保护模式
      
         ;以下进入保护模式... ...实际上处理器现在还处于16位保护模式下,在保护模式下不允许使用mov指令改变CS的内容,将会导致处理器产生一个无效操作码的异常中断
         jmp dword 0x0008:flush             ;16位的描述符选择子：32位偏移,需要注意的是,不管用的是16位远转移还是32位远转移,现在已经处于保护模式了,处理器都将把第一个操作数0x0008视为段描述符选择子,而不是实模式下的逻辑段地址,索引号1,TI位0,RPL为00,当指令执行时,处理器加载段选择器CS,从GDT中取出相应的描述符加载到CS描述符高速缓存
;jmp dword 0x0008:flush默认使用16位编译,在16位模式下译码,但按32位要求执行的指令,所以具有反转操作数的前缀0x66;清流水线并串行化处理器 
         [bits 32]                          ;使用伪指令[bits 32],之后的指令都按32位操作数编译的,当处理器执行到这,会按32位模式进行译码

    flush:
         mov cx,00000000000_10_000B         ;加载数据段描述符选择子(0x10)到段选择器DS,前3位是TI|RPL
         mov ds,cx                          ;并自动加载描述符高速缓存器

         ;以下在屏幕上显示"Protect mode OK." 
         mov byte [0x00],'P'  
         mov byte [0x02],'r'
         mov byte [0x04],'o'
         mov byte [0x06],'t'
         mov byte [0x08],'e'
         mov byte [0x0a],'c'
         mov byte [0x0c],'t'
         mov byte [0x0e],' '
         mov byte [0x10],'m'
         mov byte [0x12],'o'
         mov byte [0x14],'d'
         mov byte [0x16],'e'
         mov byte [0x18],' '
         mov byte [0x1a],'O'
         mov byte [0x1c],'K'
;堆栈段的基本情况:线性基地址为0x00000000,段界限为0x07A00(20位),粒度为字节(G=0),属于存储器的段(S=1),这是一个32位的段(D=1),该段位于内存中(P=1),特权级为0(DPL=00),可读可写,向下扩展的数据段
         ;以下用简单的示例来帮助阐述32位保护模式下的堆栈操作,77~79行用于初始化保护模式下的栈
         mov cx,00000000000_11_000B         ;加载堆栈段选择子(0x11)到SS段选择器中,前3位是TI|RPL
         mov ss,cx                          ;并自动加载描述符高速缓存器
         mov esp,0x7c00                     ;将栈指针初始化为0x7c00
;当前程序的代码段其描述符的D位是1,所以进行隐式操作时,默认地,每次压栈操作时,压入的是双字,当前程序的栈段的B位也是1,使用栈指针ESP进行操作,以下代码用于检验这一事实,详细看下面注释
         mov ebp,esp                        ;保存堆栈指针到EBP
         push byte '.'                      ;立即向栈中压入立即数（字节）
         
         sub ebp,4
         cmp ebp,esp                        ;判断压入立即数时，ESP是否减4,事实证明ESP减4
         jnz ghalt                          ;如果不相等将不会显示句点,直接转移到程序的最后,停机,因为现在已经禁止了中断,除了NMI,处理器不会被激活
         pop eax                            ;如果相等则立即将刚压入的字符出栈
         mov [0x1e],al                      ;显示句点 
      
  ghalt:     
         hlt                                ;已经禁止中断，将不会被唤醒 

;-------------------------------------------------------------------------------
     
         gdt_size         dw 0              ;dw声明1字16位,2字节
         gdt_base         dd 0x00007e00     ;dd声明双字32位,4字节,GDT的起始线性地址(物理地址)0x00007e00,从这个地方开始创建全局描述符表
;结合下面的图形,在实模式下,主引导程序的加载位置是0x0000:0x7c00,也就是物理地址0x07c00,因为现在地址是32位,所以对应着0x0000 7c00,主引导程序共512(0x200)字节,所以决定将GDT设在主引导程序之后,也就是物理地址0x0000 7e00处
         times 510-($-$$) db 0
                          db 0x55,0xaa
;以下是注释说明:
;一般来说操作系统负责整个计算机软件硬件的管理,它做任何事都是可以的,但是用户程序应当有所限制,只允许访问属于自己的数据,即使是转移,也只允许在自己的各个代码段进行
;为了让程序在内存中能自由浮动而又不影响它的正常执行,处理器将内存划分成逻辑上的段,并在指令中使用段内偏移地址,在保护模式下,对内存的访问依然使用段地址和偏移地址
;但是每个段能够访问之前,必须进行登记,当访问的偏移地址超出段的界限时,处理器就会阻止这种访问,并产生内部异常的中断
;和一个段有关的信息需要8个字节来描述,所以称为段描述符,每个段都需要一个描述符,为了存放这些描述符,需要在内存中开辟一段空间来存放,在这个段空间里,所有描述符都是集中存放
;挨在一起,构成一个描述符表,最主要的描述符表是全局描述符表(Global Descriptor Table),全局意味着该表为整个软硬件系统服务,在进入保护模式之前,必须定义全局描述符表
;为了跟踪全局描述符表,处理器内部有一个48位的寄存器,称为全局描述符表寄存器GDTR,该寄存器分为两部分,分别是32位线性地址和16位的边界,32位处理器具有32根地址线
;可以访问的地址范围是0x0000 0000到0xFFFF FFFF,共4GB内存,所以GDTR的32位线性基地址部分保存的是全局描述符表在内存中的起始线性地址
;16位边界部分保存的是全局描述符表的边界,其在数值上等于表的总字节数减一
;全局描述符表GDTR:
;47                              1615              0
;|       全局描述符表线性基地址       | 全局描述符表边界 |
;换句话说,全局描述符表的界限值就是表内最后一字节的偏移量,第一字节的偏移量是0,最后一字节的偏移量是表的大小减一,如果界限值是0,表示表的大小是一字节
;因为GDT界限是16位的,该表最大是65536字节(64KB),每个描述符占8字节,最多可以定义8192个描述符,理论上全局描述符表可以位于内存中的任何地方,但是由于在进入保护模式之后
;处理器立即按照新的内存访问模式工作,所以必须在进入保护模式之前定义GDT,实模式下只能访问1MB的内存,所以GDT通常定义在1MB以下的内存范围中,当然,允许进入保护模式后换个位置重新定义GDT
;进入保护模式前的内存映像:
;FFFFFFFF  ________________
;         |                |
;         |                |
;         |                |
;         ~                ~
;         ~                ~
;         |                |
;         |                |
;         |                |
;000FFFFF  ----------------     到这1MB
;         |                |
;         ~                ~
;         ~                ~
;         |                |
;         |                |
;          ----------------<---------因为GDT最大可以有64KB,所以理论上可以扩展到物理地址0x00017DFF处
;00017DFF |                |
;         |      GDT       |
;         |    Max=64KB    |
;         |                |
;         |                |
;         |                |
;         |                |<--------处理器的GDTR(全局描述符表寄存器),此程序将GDT定义在主引导扇区之后
;00007E00  ----------------
;00007DFF  ----------------
;         |      512B      |
;         |      MBR       |
;00007C00  ----------------
;         |   实模式栈推进   |<--------因为栈段寄存器SS和CS一样被初始化为0x0000,栈指针寄存器SP被初始化为0x7c00,栈是向下扩展的
;         |      方向下     |         所以这一部分是实际可用的栈区域,该区域包含很多BIOS数据,包括实模式下的中断向量表,一定要小心
;         |       |        |
;         |      \|/       |
;         ~                ~
;         ~                ~
;         |                |
;         |                |
;00000000  ----------------
;
;实模式和保护模式在内存访问方面是有区别的,在保护模式下不能说访问哪个段就访问那个段,在访问之前必须先在GDT内定义要访问的内存段,可能有下面的疑问
;既然想访问哪段内存就在GDT中定义一个描述符,这和直接访问有什么区别,反正也能随心所欲,何来的限制和保护?实际上并非如此,如果整个计算机系统只有一个程序在运行
;这是正确的,问题是会有很多应用程序共同在操作系统上运行,所以描述符不是用户程序自己建立的,而是加载时由操作系统根据应用程序的结构而建立的,而用户程序通常是
;无法建立和修改GDT的,只能在自己的地盘上工作,操作系统为你的程序建立了几个段,就只能在这几个段内工作,超出范围或未按照预定的方法访问这些段,都将被处理器阻止
;一旦确定了GDT在内存中的起始位置,下一步就是确定要访问的段,并在GDT中为这些段创建各自的描述符
;每个描述符在GDT中占8个字节,64位,以下是存储器的段描述符格式:
;
; 31            24 23  22  21   20  19         16 15 14 13 12 11     8 7            0 高32位
;|  段基地址31~24  | G |D/B| L | AVL | 段界限19~16 | P | DPL| S |  TYPE | 段基地址23~16 |
;
; 31                                           1615                                 0 低32位
;|                 段基地址15~0                   |             段界限15~0             |
;
;很明显,描述符中指定了32位的段起始地址,以及20位的段边界,在实模式下,段地址并非真实的物理地址,在计算物理地址时,还要左移4位(乘以16)
;但是和实模式不同,在32位保护模式下,段地址是32位的线性地址,如果未开启分页功能,该线性地址就是物理地址,没有特别说明的情况下,线性地址就是物理地址
;描述符中的段基地址和段界限是不连续的,分成几段似乎是不科学的,这也是没办法的事,这是从80286处理器上带来的后遗症,80286也是16位处理器,也有保护模式
;但是是属于16位的保护模式,而且其地址线是24位,最多允许访问16MB内存,尽管80286未能形成气候,但是32位处理器为了保持兼容,不得已只能在旧的描述符格式上进行扩充
;段基地址可以是0~4GB范围内的任意地址,不过还是建议应当选取那些16字节对齐的地址,尽管对于Intel处理器来说允许不对齐的地址,但是对齐能够使程序访问代码和数据时性能最大化
;20位的段界限用来限制段的扩展范围,因为访问内存的方法是用段基地址加上偏移量,所以对于向上扩展的段,如代码段和数据段来说,偏移量是从0开始递增的,段界限决定了偏移量的最大值,对于向下扩展的段,如栈段来说,段界限决定了偏移量的最小值
;G位是粒度位(Granularity),用于解释段界限的含义,当G位是0时,段界限以字节为单位,此时段的扩展范围是从1字节到1MB,因为描述符中的界限值是20位的,如果G位是1,那么段界限是以4KB为单位的,此时段的扩展范围是从4KB到4GB
;D/B位是默认操作数大小(Default Operation Size)或默认的栈指针大小(Default Stack Pointer Size)又或者上部边界(Upper Bound)标志,设立该标志位主要是为了能够在32位处理器上兼容运行16位保护模式程序,尽管这种程序已经非常罕见了
;该标志位对不同的段由不同的效果,此位对于代码段来说称作D位,用于指示指令中默认的偏移地址和操作数尺寸,D=0表示指令中的偏移地址或者操作数是16位的,D=1表示是32位的
;如果代码段的描述符D位是0,那么当处理器在这个段上执行时将使用16位的指令指针寄存器IP来取指令,否则使用32位的EIP
;该标志位对于栈段来说称作B位,用于进行隐式的栈操作时,是使用SP寄存器还是ESP寄存器,隐式栈操作指令包括push,pop,call等,如果该位是0,在访问那个段时,使用SP寄存器,否则使用ESP寄存器
;同时B位的值也决定了栈的上部边界,如果B=0,那么栈段的上部边界(也就是SP寄存器的最大值)为0xFFFF,如果B=1,那么栈段的上部边界(也就是ESP寄存器的最大值)为0xFFFF FFFF,对于本书来说应当为1
;L位是64位代码段标志,保留此位给64位处理器使用,目前将此位置0即可
;AVL是软件可以使用的位(Available),通常是由操作系统来用,处理器并不使用它
;P位是段存在位(Segment Present),P位用于指示描述符所对应的段是否存在,一般来说描述符所指示的段都位于内存中,但是当内存空间紧张时,有可能只是建立了描述符,对应的内存空间并不存在,这时就应将P位清零以表示段不存在
;另外,同样是在内存空间紧张时,会把很少用到的段换出到硬盘,腾出空间给当前急需内存的程序使用(当前正在执行的),这时同样要把P位清零,当再次轮到它执行时,再装入内存并将P位置1
;P位是处理器负责检查的,每当通过描述符访问内存中的段时,如果P位是0,处理器就会产生一个异常中断,通常该中断处理过程是由操作系统提供的,该处理过程的任务是负责将该段从硬盘换回内存,并将P位置1
;在多用户,多任务的系统中,这是一种常见的虚拟内存调度策略,当内存很小,运行程序很多时,如果计算机运行速度变慢,并伴随着繁忙的硬盘操作时,说明这种情况正在发生
;DPL表示描述符的特权级(Descriptor Privilege Level),这两位用于指定段的特权级,共有4种处理器支持的特权级别,分别是0,1,2,3,其中0是最高特权,3是最低特权,刚进入保护模式时执行的代码具有最高特权0,可以看成是从处理器那继承而来的
;这些代码通常是操作系统代码,因此它的特权级别最高,每当操作系统加载一个用户程序时,通常都会指定一个稍低的特权级别,比如3级特权,不同特权级的应用程序是相互隔离的,其互访是严格限制的,而且有些处理器指令(特权指令)只能由0特权级的程序来执行,以保证安全
;在这里,描述符的特权级用于指定要访问该段所必须具有的最低特权级,如果这里的数值是2,那么只有特权级别为0,1,2的程序才能访问该段,而特权级别为3的程序访问该段时会被处理器阻止,目前一律设置为0
;S位用于指定描述符的类型,当该位是0时表示是一个系统段,为1时表示是一个代码段或者数据段(栈段是特殊的数据段)
;TYPE字段总共4位,用于指示描述符的子类型,或者说类别,对于数据段来说,这4位分别是X   E   W   A
;
;   X   E   W   A       描述符类别  表示的含义
;   0   0   0   x(叉)               只读,向上扩展
;   0   0   1   x         数据      读写,向上扩展
;   0   1   0   x                  只读,向下扩展
;   0   1   1   x                  读写,向下扩展
;
;对于代码段来说,这4位分别是X   C   R   A
;
;   X   C   R   A       描述符类别  表示的含义
;   1   0   0   x(叉)               只执行
;   1   0   1   x         代码      执行,读
;   1   1   0   x                   只执行,依从的代码段
;   1   1   1   x                   执行,读,依从的代码段
;
;X表示是否可以执行(eXecutable),数据段总是不可执行的,X=0,而代码段总是可以执行的,X=1
;对于数据段来说,E位指示段的扩展方向,E=0表示段是向上扩展的,也就是向高地址方向扩展,是普通的数据段,E=1是向下扩展的,也就是向低地址方向扩展,通常是栈段
;W位指示段的读写属性,或者说段是否可写,W=0的段是不允许写入的,否则会引发处理器异常中断,W=1可以正常写入
;对于代码段来说,C位指示段是否为特权级依从的(Conforming),C=0表示非依从的代码段,这样的代码段可以从与它特权级相同的代码段调用,或者通过门调用,C=1表示允许从低特权级的程序转移到该段执行
;R位指示代码段是否允许读出,代码段总是可以执行的,但是为了防止程序被破坏,它是不能写入的,至于是否有读出的可能,由R位指定,R=0表示不能读出,如果企图去读取会引发处理器异常中断,R=1表示可以读出,可以把这个代码段当成ROM一样使用
;既然代码段是不可读的,那么处理器怎么从里面取指令,事实上这里的R属性并非用来限制处理器,而是用来限制程序和指令的行为,典型例子是使用段超越前缀CS:来访问代码段中的内容
;数据段和代码段的A位是已访问位,用于指示它所指向的段最近是否被访问过,在描述符创建的时候应当清零,之后,每当该段被访问,处理器自动将该位置1
;对该位清零是由操作系统负责的,通过定期监视该位的状态,就可以统计出该段的使用频率,当内存空间紧张时,可以把不经常使用的段退避到硬盘,实现虚拟内存管理
;
;从现在开始安装各个描述符,回到代码,现在还处于实模式下,因此在GDT中安装描述符必须将GDT的线性地址(物理地址)转换成逻辑段地址和偏移地址,GDT地址是直接给出的,放在标号gdt_base处
;第12行将GDT线性基地址的低16位传送到AX,因为主引导扇区的实际加载位置是0x0000:0x7c00,所以标号gdt_base处的偏移地址是gdt_base+0x7c00,如代码注释
;                               关于第21条地址线A20的问题
;在进入保护模式之前,还涉及一个历史遗留问题,那就是处理器的第21根地址线,编号A20,在8086处理器上不存在A20问题,因为8086只有20根地址线,实模式下的程序只能寻址1MB的内存
;因为依赖16位的段地址左移4位加上16位的偏移地址形成物理地址,无论如何,从8086处理器外部来看,每次当物理地址达到最高端0xFFFFF时,加一结果为0x100000,进位被丢弃又绕回最低端0x00000,段内偏移也是如此
;到了80286时代,处理器有24条地址线,地址回绕不灵了,但是为了能在80286上运行8086程序而不会因为地址线产生冲突的解决办法是强制A20为0,所以IBM公司使用一个与门来控制A20
;并把这个与门的控制阀门放在键盘控制器内,端口号是0x60,向该端口写入数据时,如果第1位是1,那么键盘控制器通向与门的输出就为1,与门的输出取决于处理器A20是0还是1
;不过这种做法非常繁琐,因为要访问键盘控制器,需要先判断状态,要等待键盘控制器不忙,需要的步骤太多,这种做法持续了若干年,直到80486出现才有了更快速的办法
;
; ---------------- 
;|                |----------------------------------------
;|  处理器         |-----A20--------+                 +-----
;|                |                |                 |
;|                |                |                 |                  早期的A20控制策略
;|                |                |                 |
; ----------------                 |                 |
;                                  |_______ ___      |
;                                          |   |-----+
;键盘--8042键盘控制器接口(0x60端口)------------|__ |
;
;
; ---------------- 
;|           INIT#|                         ICH芯片
;|  处理器         |                 -----------------------
;|                |                |  ___                  |
;|                |                | |   |-----快速A20和初始化寄存器
;|           A20M#|------------------| + |        端口号0x92|
; ----------------                 | |___|__               |            改进后的A20控制策略
;                                  |        |              |
;                                  |________|______________|
;                                           |
;老键盘控制器---------------------------------+
;端口号0x60
;从80486开始,处理器本身就有A20M#引脚,意思是A20屏蔽(A20 Mask),它是低电平有效的,如上图所示
;输入输出控制器集中芯片ICH的处理器接口部分,有一个用于兼容老式设备的端口0x92,第7~2位保留,第0位叫做INIT_NOW(现在初始化),用于初始化处理器
;当它从0过渡到1时,ICH芯片会使处理器INIT#引脚的电平变低(有效),并至少保持16个PCI时钟周期,通俗来说,向这个端口写1,将会使处理器复位,导致计算机重新启动
;端口0x92的位1用于控制A20,叫做替代的A20门控制(ALT_A20_GATE),它和来自键盘控制器的A20控制线一起,通过或门连接到处理器的A20M#引脚,和使用键盘控制器的端口不同,通过0x92端口非常快,称为Fast A20
;当INIT_NOW(现在初始化)从0过渡到1时,ALT_A20_GATE将被置1,这就是说计算机启动时,第21根地址线是自动启用的,A20M#信号仅用于单处理器系统,多核处理器一般不用,特别是考虑到传统键盘控制器正在被USB取代
;第40~42行,先从该端口读出源数据,接着将第2位(位1)置1,再写回0x92端口,打开A20
;
;至此到达实模式和保护模式的边界,控制这两种模式切换的开关在CR0寄存器(处理器内部的控制寄存器Control Register),32位寄存器,包含一系列用于控制处理器操作模式和运行状态的标志位
;位0是保护模式允许位(Protection Enable),如果把该位置1,处理器进入保护模式,按保护模式的规则开始运行
;保护模式下的中断机制和实模式不同,原有的中断向量表不再适用,在保护模式下,BIOS中断都不能再用,因为它们是实模式下的代码,再重新设置保护模式下的中断环境之前,必须关闭中断
;
;在实模式下,处理器访问内存的方式是将段寄存器的内容左移4位(乘以16),再加上偏移地址以形成20位物理地址,8086的段寄存器是16位的,由CS,DS,ES,SS,而在32位处理器上增加了FS,GS
;这6个段寄存器又分为两部分,前16位和8086相同,在实模式下按传统方式寻址1MB内存,使得8086程序可以继续在32位处理器上执行
;每个寄存器又有一个不可见的部分,称为描述符高速缓存器,用来存放段的线性基地址,段界限和段属性,由处理器内部使用
;   mov cx,0x2000
;   mov ds,cx
;   mov [0xc0],al
;首先将ds设置为0x2000,这是逻辑段地址,接着向该段内偏移地址位0x00c0的地方写入1字节,写入时,处理器将DS左移4位,加上偏移地址,实际写入的物理地址是0x200c0
;以上在8086处理器上是正确的,但是在32位处理器上,每当引用一个段时,处理器自动将段地址左移4位,并传送到描述符高速缓存器,此后就一直使用描述符高速缓存器的内容作为段地址
;所谓引用一个段,就是执行将段地址传送到段寄存器的指令,通常是用转移或调用指令,比如jmp 0xf000:0x5000
;但是实模式下只能向段寄存器传送16位的逻辑段地址,即处理器不将它看成是描述符选择子,所以处理器只能访问1MB内存,也就是说在实模式下
;段寄存器描述符高速缓存器的内容仅低20位有效,高12位全0
;实模式下的6个段寄存器在保护模式下称为段选择子,和实模式不同,保护模式有自己的内存访问方式,尽管访问内存时也需要指定一个段,但是传送到段选择器的内容不是逻辑段地址,而是段描述符在描述符表中的索引号
;在保护模式下访问一个段时,传送到段选择器的是段选择子,由三部分组成:
;第一部分是描述符的索引号,用来在描述符表中选择一个段描述符
;TI是描述符表指示器(Table Indicator),TI=0时,表示描述符在GDT中,TI=1时,描述符在LDT中(也是一个描述符表,跟GDT类似)
;RPL是请求特权级,表示给出当前选择子的那个程序的特权级别,正是该程序要访问这个段
;段选择子的组成:
;15                          3   2  1    0
;|          描述符索引          | TI | RPL |
;前面已经创建了全局描述符表,而且定义了4个段描述符,数据段在GDT中的顺序是第3个,因为编号是从0开始的,所以索引号是2
;                                                                      索引号 TI RPL
;为了说明保护模式下的内存访问,回到代码,第56~57行,将描述符选择子0x0010(0000 0000 00010 0 00)传送到段选择器DS中
;从选择子的二进制形式可以看出,指定的描述符索引号是2,指定的描述符表是GDT,请求特权级别是00
;GDT的线性基地址在GDTR中,每个描述符占8个字节,描述符在表内的偏移地址是索引号乘以8,如下图所示,当处理器执行任何改变段选择器的指令时,就将指令中提供的索引号乘以8作为偏移地址
;同GDTR提供的线性基地址相加,以访问GDT,如果没有发现什么问题(如越界),就自动将找到的描述符加载到不可见的描述符高速缓存部分,加载的部分包括
;段的线性基地址,段界限,段的访问属性,当前例子中,段的基地址是0x000B8000,段界限是0x0ffff,段的属性是粒度为字节,可读写的,向上扩展的数据段
;
;                                                             FFFF FFFF ----------
;                                                                      |          |
;                                                                      |          |
;                                                                      |          |
;                       DS现在是段选择器                                 ~          ~
;       +---------------Multiply By 8---------------------+            ~          ~
;       |                                                 |            |          |
;       |                                                 |            |          |
;      -+------------------                               |            |          |
;     | |                  |                              |             ----------
;     | |                  |                              |            |          |
;     | |                  |                              |            |          |
;     | |                  |                             \|/           |   GDT    |Third:
;     | |     GDTR---------+---------------------------->plus--------->|          +>>---+
;     | |                  |                       Second:             |          |     |
;     | |                  |                                            ----------      |
;     | |                  |                                           |          |     |
;     | |                  |                                           |          |     |
;     | |                  |                                  0000 0000 ----------      |
;     | |                  |                                                            |
;     | |                  |                                                            |
;     | DS{描述符高速缓存器 <}+------------------------------------------------------------+
;     |/|\                 |
;     |_|__________________|
;       |
;       |
;First:段选择子TI=0,表示描述符在GDT中
;
;此后每当有访问内存的指令时,就不再访问GDT中的描述符,直接用当前段寄存器描述符高速缓存器提供的线性基地址,因此第60行,指令中没有段超越前缀,默认使用数据段寄存器DS
;执行这条指令时,处理器用DS描述符高速缓存器中的线性基地址加上指令中的偏移量0x00,形成32位物理地址,不单单是访问数据段,即使是处理器取指令执行时,也采用相同的办法
;在32位保护模式下,处理器使用的指令指针寄存器是EIP,假设已经从描述符表中选择了一个段描述符,CS描述符高速缓存器已经装载了正确的32位线性基地址,那么当处理器取指令时
;会自动用描述符高速缓存器中的32位线性基地址加上指令指针寄存器EIP中的32位偏移量,形成32位物理地址,取得指令并加以执行,同时,EIP自增以指向下一条指令
;
;   mov byte [0x00],'P'
;                |
;                |
;                +------------段内偏移---------------------+
;                                                         |   FFFF FFFF ----------
;                                                         |            |          |
;      --------------------                               |            |          |
;     |                    |                              |            |          |
;     |                    |                             \|/           |          |
;     |        CPU         |                             plus--------->|     P    |0x000 B8000
;     |                    |                             /|\           |          |
;     |                    |                              |            |          |
;     |                    |                              |            |          |
;     |                    |                              |   0000 0000 ---------- 
;     |                    |                              |
;     |                    |                              |
;     | DS  描述符高速缓存器----------32位线性基地址----------+
;     |                    |
;     |____________________|
;
;                                                             FFFF FFFF ----------
;                                                                      |          |
;      --------------------                                            |          |
;     |             EIP-----------------------------------+            |          |
;     |                    |                             \|/           |          |
;     |        CPU         |                             plus--------->|   指令    |
;     |                    |                             /|\           |          |
;     |                    |                              |            |          |
;     |                    |                              |            |          |
;     |                    |                              |   0000 0000 ---------- 
;     |                    |                              |
;     |                    |                              |
;     | CS  描述符高速缓存器----------32位线性基地址----------+
;     |                    |
;     |____________________|
;
;                               清空流水线并串行化处理器(重新按指令的自然顺序执行)
;看起来内容有点超前,毕竟刚设置了CR0的PE位,处理器刚刚切换到保护模式下,看起来一切都很简单,其实不是这样的,还有两个要解决的问题
;第一:即使是在实模式下,段寄存器的描述符高速缓存器也被用于访问内存,仅低20位有效,高12位全是0,当处理器进入保护模式时,这些内容还残留着,虽然不影响使用
;但这些内容在保护模式下是无效的,迟早会出问题,因此比较安全的做法是尽快刷新各个段寄存器的内容,包括段选择器和描述符高速缓存器
;第二:在进入保护模式之前,很多指令已经进入流水线,因为处理器工作在实模式下,所以它们都是按16位操作数和16位地址长度进行译码的,即使是那些用bit 32编译的指令
;进入保护模式之后,受CS段描述符高速缓存器中实模式残留内容的影响,处理器进入16位保护模式工作,如果保护模式下的代码是16位的,影响可能不大,但如果是用32位编译的
;那么由于对操作数和默认地址大小的解释不同,指令的执行结果可能会不正确,所以必须清空流水线,同时那些通过乱序执行得到的中间结果也是无效的,必须清理掉,让处理器串行化执行,即重新按指令的自然顺序执行
;这里有一个两全其美的方案,就是使用远转移指令jmp或远过程调用指令call,处理器最怕遇到转移指令,一般会清空流水线并串行化执行
;另一方面远转移会重新加载段选择器CS,并刷新描述符高速缓存器中的内容,一个建议的方法是在设置了CR0的PE位后,立即用jmp或call指令转移到当前指令流的下一条指令上,如第51行,32位远转移指令
;   jmp dword 0x0008:flush  这条指令和前面的指令一样,默认用bit 16编译的,而且使用了关键字dword,该关键字修饰偏移地址,要求使用32位的偏移量,会有指令前缀0x66
;编译后的结果   66 EA 80 00 00 00 08 00     实际上处理器现在还处于16位保护模式下,使用下面的16位远转移指令可能更自然些,详细间最后的注释说明
;   jmp 0x0008:flush        同样用bit 16编译生成    EA 7B 00 08 00
;16位远转移指令只有5个字节,使用16位偏移量,他会使标号flush的汇编地址相应地变小,变成0x007B,而不是0x0080,因为指令变短了
;16位保护模式是80286引入的,80286没有对8086的寄存器进行扩展,所以在16位保护模式下,段可以起始于任何地方,但是最大64KB,只使用16位偏移量,为了绕开16位保护模式,这里使用32位远转移指令
;需要注意的是,不管用的是16位远转移还是32位远转移,现在已经处于保护模式了,处理器都将把第一个操作数0x0008视为段选择子,而不是实模式下的逻辑段地址
;因为处理器实际上是在保护模式下执行该指令的,因此会重新解释这条指令的含义
;操作数的默认大小(16或32位)是由描述符的D位决定的,确切说是由段寄存器的描述符高速缓存器中的D位决定的,必将要访问一个段,必须首先将它的描述符传送到段寄存器的描述符高速缓存器中
;当它刚进入保护模式时,CS的描述符高速缓存器依然保留着实模式的内容,D位=0,在那个时刻,处理器处于16位保护模式
;又因为处理器进入保护模式了,所以0x0008不再是逻辑段地址,而是段描述符选择子,前面定义GDT时,第2个(1号)描述符对应着保护模式下的代码段,因此,其选择子为0x0008(索引号1,TI=0,RPL=00)
;当指令执行时,处理器加载段选择器CS,从GDT取出相应的描述符加载到CS描述符高速缓存
;保护模式下的代码段,基地址为0x0000 7c00,段界限为0x1ff,长度为0x200,正好对应着当前程序在内存中的区域,在这种情况下,上面那条指令执行加载到时,目标位置在段内的偏移量就是标号flush的汇编地址
;处理器用它的数值代替EIP原有的内容,在16位保护模式下执行带前缀0x66的指令,那么很好,处理器会按32位方式执行,使用32位偏移量,于是它将0x0008加载到CS选择器,并从GDT取出对应的描述符
;加载CS描述符高速缓存器,同时把指令中给出的32位偏移量传送到EIP
;从进入保护模式开始,之后的指令都应当是按32位操作数编译的,因此第53行使用了伪指令bit 32,当处理器执行到这里时,会按32位模式进行译码,正是我们想要的
;
;                               保护模式下的栈
;栈是向下扩展的,因此描述符中的段界限,和向上扩展的段含以不同,对于向上扩展的段,段内偏移是从0开始递增,偏移量的最大值是界限值和粒度的乘积
;对于向下扩展的段来说,因为经常用作栈段,而栈是从高地址向低地址推进的,所以段内偏移地址的最小值是界限值和粒度的乘积加1,32位代码中,使用EIP作为栈指针的,这里的段界限用来和粒度一起决定EIP的最小值
;即栈操作时,必须符合条件:   EIP>段界限 X 粒度值(对于描述符中G位是0的段来说,粒度值是1(字节),G位是1的段来说,粒度值是4096(4KB))
;要是不符合条件,那么再压入数据就越界了
;在当前代码中,ESP寄存器被初始化为0x7c00,假如此时执行指令:
;   push edx
;那么要压入一个32位数,所以处理器先将ESP减去4,再压入数据,此时ESP=0x0000 7c00-4=0x7bfc
;当前段界限为0x07a00,粒度是字节,故作为栈的界限,实际使用的数值是0x0000 7A00
;对于栈段来说,段界限值加1,就是段内偏移量的最小值,因为要访问的段内偏移量0x0000 7bfc大于实际使用的段界限0x0000 7A00,所以处理器允许该操作,并用描述符高速缓存器中的32位
;基地址0x0000 0000加上这里的偏移量0x0000 7bfc,形成32位物理地址访问栈,将EDX的内容压入,否则处理器阻止并产生异常中断,可能会觉得当前的栈段很完美,但是这是一个糟糕的定义
;本意是要定义一个只有512字节的栈空间,从0x0000 7A00开始,到0x0000 7C00结束,但是从该段的描述符来看,这个段的空间非常巨大,在程序正常的情况下不会有什么问题
;但是在程序错误的时候,ESP可能有预料不到的值,比如0xFFFF FFFF,即使是这样,也是合法的值,因为大于0x0000 7A00,因为当前栈段的线性基地址位0x0000 0000
;所以实际可访问的空间是从0xFFFF FFFF到0x0000 7A00,超出预期,下一章将会有更好的方式创建栈
;
;剩下的指令用于演示保护模式下的栈操作,对于存储器的段来说,其描述符的D/B位,代码段是D位,栈段是B位,隐式的栈操作(push,pop,call,ret,iret)涉及两个段
;一是指令所在的代码段,二是指令执行时所使用的栈段,在当前程序的代码段,其描述符的D位是1,所以进行隐式的栈操作时,压栈时压入的是双字,当前程序的栈段的描述符的B位也是1
;默认使用ESP进行操作,从第81行代码开始检验这一事实
;因为当前正在执行的代码段是32位的,描述符D位是1,push指令默认操作数的大小是32位,而关键字byte仅仅是给编译器用的,告诉编译器该指令对应的格式为push imm8,必须使用操作码0x6A
;而不是用来在编译后的机器指令前添加指令前缀,因此处理器在执行该指令时,压入栈中的是一个双字(4字节),高24位是该字节符号的扩展
;当指令执行时,所访问的栈的描述符B位也是1,用的是ESP,首先将ESP减去4,在写入数值,数据保存的位置是SS:ESP
;不存在从栈中弹出字节的指令,因为名义上可以压入字节,但实际上它们是作为16位或32位有符号数压入的
;
;                               处理器刚加电时的段寄存器状态
;X86处理器加电后,它的固件会对自身进行初始化,可选地,还可以执行一个内置的自测试(Build-In Self-Test),如果执行了BIST,当测试通过时,EAX被清零,否则EAX非零,如果不执行BIST,那么EAX内容默认地也是0
;这些工作完成后才开始取指令,不管怎么样,处理器初始化完成后,各个寄存器都有一个预设的值,详细参考Intel手册
;8086处理器访问内存时,把16位段寄存器的内容左移4位,加上16位偏移地址
;在32位处理器上,每次向段寄存器传送逻辑地址时,处理器即在段寄存器描述符高速缓存器中存放一个左移后的20位基地址
;即使是在实模式下,处理器也是用段寄存器描述符高速缓存器的32位基地址加上16位的偏移地址,只不过基地址的高12位通常是0
;例外是处理器刚刚加电时,CS段描述符高速缓存器中的基地址被强制为0xFFFF 0000,这使得处理器取第一条指令时,地址线的高位部分被强制为1
;又因为加电后,EIP预置内容是0x0000 FFF0,所以处理器第一次取指令时发出的地址是0xFFFF FFF0,之所以这样是因为处理器的设计者希望把ROM-BIOS放到4GB可寻址范围的最高端
;这样4GB以下,连同传统的低端1MB都是连续的RAM区,能为操作系统管理内存带来方便,问题在于老的硬件和软件依赖于低端的1MB的ROM-BIOS来工作,最终这两个地址区段都指向同一块ROM芯片
;在Bochs中可以看出即将执行的第一条指令是jmp far f000:e05b,当这条指令执行后,处理器用f000左移4位存放到描述符高速缓存器,于是处理器地址线的高位部分不再是1,又转到低地址端的BIOS了
;Bochs还显示了GDTR的内容,基地址0,表界限0xFFFF
;要注意的是,在进入主引导程序时,各个段寄存器以及GDTR的内容和处理器刚加电时不同,因为BIOS加电自检程序在执行期间要进入保护模式进行测试,将改变相关段寄存器的内容
;
;                               设置PE位后的段寄存器状态
;一旦设置了CR0的PE位,处理器就进入保护模式,但是,除非我们主动刷新段寄存器的内容,否则段寄存器依然保持着实模式的内容,也就是刚进入保护模式的段寄存器的内容是实模式下段寄存器的内容
;尽管如此,这对处理器没有影响,因为在保护模式下,对描述符有效与否的检查,通常只在加载段寄存器(选择器),并刷新描述符高速缓存器的时候进行,对代码段来说,典型的例子是远转移或远过程调用
;比如   jmp 0x0008:0x0002   ,对于代码段来说,典型例子是加载段选择子,比如     mov ds,ax
;当这类指令执行时,处理器用指令中给出的选择子找到描述符,如果描述符有效,就将选择子加载到段寄存器(选择器),并把描述符加载到描述符高速缓存器,不合格无效的描述符不可能被加载
;当前情况比较特殊,是进入保护模式前遗留下来的
;
;                               jmp指令执行后的段寄存器状态
;前面说过,X86处理器的保护模式分为两种:16位保护模式和32位保护模式,处理器加电,设置CR0寄存器的PE位后,CS描述符高速缓存器的D位是0,处理器根据此位将自己的状态设置为16位保护模式
;16位保护模式和实模式相比,在指令格式和寻址方式上是相同的,因此如果进入保护模式后的指令是16位指令,理论上不会有问题,实际上因为各个段寄存器,特别是数据段寄存器中的内容并没有更新
;不适当的内存访问将导致不可预知的问题,以上所说,是解释为什么进入保护模式后处理器还能接着往下执行的原因
;问题在于虽然还能按原来的执行流程执行,但后面的代码是32位编译的,当处理器处在16位保护模式时,它会按16位的方式译码32位指令,这是不行的
;因此,第51行使用    jmp dword 0x0008:flush  机器码66 EA 7E 00 00 00 08 00
;这是一个默认使用16位编译,在16位模式下译码,但按32位要求执行的指令,所以具有反转操作数的前缀0x66
;执行后会更新CS及其描述符高速缓存器,D位为1,32位模式