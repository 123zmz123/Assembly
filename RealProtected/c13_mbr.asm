         ;代码清单13-1
         ;文件名：c13_mbr.asm
         ;文件说明：硬盘主引导扇区代码 
         ;创建日期：2011-10-28 22:35        ;设置堆栈段和栈指针 
         
         core_base_address equ 0x00040000   ;常数，内核加载的起始内存地址 
         core_start_sector equ 0x00000001   ;常数，内核的起始逻辑扇区号 
         ;设置SS=0x0000 0000,SP=0x7c00
         mov ax,cs      
         mov ss,ax
         mov sp,0x7c00
      
         ;计算GDT所在的逻辑段地址
         mov eax,[cs:pgdt+0x7c00+0x02]      ;GDT的32位物理地址,执行后EAX=0x00007e00(我们决定要加载GDT的位置)
         xor edx,edx                        ;清零EDX
         mov ebx,16
         div ebx                            ;分解成16位逻辑地址 

         mov ds,eax                         ;令DS指向该段以进行操作
         mov ebx,edx                        ;段内起始偏移地址 
         ;以下建立保护模式下的描述符
         ;跳过0#号描述符的槽位
         ;创建1#描述符，这是一个数据段，对应0~4GB的线性地址空间
         mov dword [ebx+0x08],0x0000ffff    ;基地址为0，段界限为0xF FFFF,特权级00
         mov dword [ebx+0x0c],0x00cf9200    ;粒度为4KB，操作数32位,类型为数据段读写,存储器段描述符,段存在于内存中

         ;创建保护模式下初始代码段描述符
         mov dword [ebx+0x10],0x7c0001ff    ;基地址为0x0000 7c00，界限0x1FF,特权级00
         mov dword [ebx+0x14],0x00409800    ;粒度为1个字节，操作数32位,类型为代码段只执行,代码段描述符,段存在于内存中

         ;建立保护模式下的堆栈段描述符
         mov dword [ebx+0x18],0x7c00fffe    ;基地址为0x0000 7C00，界限0xF FFFE,特权级00
         mov dword [ebx+0x1c],0x00cf9600    ;粒度为4KB,操作数32位,类型为特殊数据段栈段向下扩展,段存在于内存中
         
         ;建立保护模式下的显示缓冲区描述符
         mov dword [ebx+0x20],0x80007fff    ;基地址为0x000 B8000，界限0x0 7FFF,特权级00
         mov dword [ebx+0x24],0x0040920b    ;粒度为字节,操作数32位,类型为数据段读写,段存在于内存中
         
         ;初始化描述符表寄存器GDTR
         mov word [cs: pgdt+0x7c00],39      ;描述符表的界限,因为总共5个描述符,每个描述符8字节  
 
         lgdt [cs: pgdt+0x7c00]             ;加载GDTR寄存器
      
         in al,0x92                         ;读南桥芯片内的端口0x92到al 
         or al,0000_0010B                   ;将从端口0x92读到的内容的第二位置1
         out 0x92,al                        ;将改动后的al写回端口0x92,打开A20

         cli                                ;中断机制尚未工作

         mov eax,cr0                        ;读出cr0的内容到eax
         or eax,1                           ;将从cr0读到的内容的第一位也就是PE位置1,准备进入保护模式
         mov cr0,eax                        ;设置PE位,将eax的内容写回cr0将导致处理器从实模式切换到保护模式
      
         ;以下进入保护模式... ...
         jmp dword 0x0010:flush             ;16位的描述符选择子：32位偏移,dword关键字修饰偏移地址,要求使用32位偏移量,因为现在处理器已经进入保护模式,将第一个操作数0x0010视为段选择子,而不是实模式下的逻辑段地址
                                            ;清流水线并串行化处理器,这里的段选择子选择的是2号描述符,也就是代码段描述符,基地址变成0x7c00,所以跳到flush处执行
         [bits 32]               
  flush:                                  
         mov eax,0x0008                     ;加载数据段(0..4GB)选择子,0x08=0000 1 000,选择1号描述符
         mov ds,eax                         ;使DS指向全部4GB的内存空间
      
         mov eax,0x0018                     ;加载堆栈段选择子,0x0001 1 000,选择3号描述符
         mov ss,eax                         ;使SS指向初始的栈空间
         xor esp,esp                        ;清零堆栈指针 <- 0
;接下来是从硬盘把内核程序读入内存,67~69行,它在硬盘上的起始逻辑扇区号和物理内存地址已经由两个常数给出,分别传送到EAX和EDI寄存器
         ;以下加载系统核心程序
         mov edi,core_base_address          ;前面定义的常数，core_base_address是内核加载的起始内存地址
      
         mov eax,core_start_sector          ;前面定义的常数，core_start_sector是内核的起始逻辑扇区号
         mov ebx,edi                        ;起始地址
         call read_hard_disk_0              ;以下读取程序的起始部分（一个扇区）,注意,调用段内过程read_hard_disk_0时,处理器会将调用返回后要执行的下一条指令的偏移地址压入栈中,所以栈底的数据是0xae(占用4字节,从0x7bff到0x7bfc),然后才是eax
;因为段寄存器DS现在指向4GB内存段,其描述符高速缓存器中的基地址是0x0000 0000,所以第75行,可以直接用EDI寄存器中的数值作为偏移量来访问内存,最终生成的线性地址在数值上和EDI寄存器的内容相同
         ;以下判断整个程序有多大,读取内核头部信息,现在段寄存器DS指向的是全部4G内存空间,其描述符高速缓存器中的基地址是0x0000 0000
         mov eax,[edi]                      ;核心程序尺寸,内核头部偏移0处的双字是核心程序总长度
         xor edx,edx                        ;将取得的总字节数除以512,EAX寄存器得到内核所占用的扇区数,不过在没能整除的情况下,实际扇区数比EAX寄存器中的值多1
         mov ecx,512                        ;512字节每扇区
         div ecx
;如果EDX不为0,则EAX寄存器实际上就是剩余扇区数,因为它比实际扇区数少1,相反,如果EDX为0,则EAX中的内容就是总扇区数,还要用dec指令减去1才行
         or edx,edx                         ;如果EDX不为0,则EAX寄存器实际上就是剩余扇区数,因为它比实际扇区数少1,相反,如果EDX为0,则EAX中的内容就是总扇区数,还要用dec指令减去1才行
         jnz @1                             ;未除尽，因此结果比实际扇区数少1
         dec eax                            ;已经读了一个扇区，扇区总数减1
   @1:;但是无论哪种情况,指令的执行流程都会到达第83行
         or eax,eax                         ;考虑实际长度≤512个字节的情况,这条指令是用来检查EAX寄存器,看内容是否为零
         jz setup                           ;EAX=0 ?如果为零,那么内核就只占用了一个扇区,于是不再读硬盘,直接跳转到setup处执行,这种情况一般不太可能

         ;读取剩余的扇区
         mov ecx,eax                        ;32位模式下的LOOP使用ECX
         mov eax,core_start_sector
         inc eax                            ;从下一个逻辑扇区接着读
   @2:
         call read_hard_disk_0
         inc eax
         loop @2                            ;循环读，直到读完整个内核

 setup:
         mov esi,[0x7c00+pgdt+0x02]         ;不可以在代码段内寻址pgdt，但可以通过4GB的段来访问
         ;esi中是GDT的基地址                  ;段寄存器DS现在指向4GB内存段,其描述符高速缓存器中的基地址是0x0000 0000
         ;建立公用例程段描述符
         mov eax,[edi+0x04]                 ;公用例程代码段起始汇编地址,前面代码中将内核加载的起始地址保存在edi中
         mov ebx,[edi+0x08]                 ;核心数据段汇编地址
         sub ebx,eax
         dec ebx                            ;公用例程段界限在ebx
         add eax,edi                        ;公用例程段基地址,用公共例程段的起始汇编地址加上内核的加载地址,就是公共例程段的基地址
         mov ecx,0x00409800                 ;字节粒度的代码段描述符,特权级DPL=00
         call make_gdt_descriptor
         mov [esi+0x28],eax
         mov [esi+0x2c],edx
       
         ;建立核心数据段描述符
         mov eax,[edi+0x08]                 ;核心数据段起始汇编地址
         mov ebx,[edi+0x0c]                 ;核心代码段汇编地址 
         sub ebx,eax
         dec ebx                            ;核心数据段界限
         add eax,edi                        ;核心数据段基地址
         mov ecx,0x00409200                 ;字节粒度的数据段描述符,特权级DPL=00
         call make_gdt_descriptor
         mov [esi+0x30],eax
         mov [esi+0x34],edx 
      
         ;建立核心代码段描述符
         mov eax,[edi+0x0c]                 ;核心代码段起始汇编地址
         mov ebx,[edi+0x00]                 ;程序总长度
         sub ebx,eax
         dec ebx                            ;核心代码段界限
         add eax,edi                        ;核心代码段基地址
         mov ecx,0x00409800                 ;字节粒度的代码段描述符(只执行),特权级DPL=00
         call make_gdt_descriptor           ;构造描述符
         mov [esi+0x38],eax
         mov [esi+0x3c],edx

         mov word [0x7c00+pgdt],63          ;修改描述符表的界限
                                        
         lgdt [0x7c00+pgdt]                 ;重新加载GDTR,使上面那些对GDT的修改生效

         jmp far [edi+0x10]                 ;前面的EDI加载的是core_base_address,也就是内核的加载地址,这将会跳转到内核偏移0x10处,也就是内核代码标号start处(内核入口),详情看代码清单c13_core.asm第28行
       
;-------------------------------------------------------------------------------
read_hard_disk_0:                        ;从硬盘读取一个逻辑扇区
                                         ;EAX=逻辑扇区号
                                         ;DS:EBX=目标缓冲区地址
                                         ;返回：EBX=EBX+512 
         push eax                        ;压栈保存要用到的寄存器
         push ecx
         push edx
      
         push eax
         ;设置要读取的扇区数,这个数值要写入0x1f2端口
         mov dx,0x1f2
         mov al,1
         out dx,al                       ;读取的扇区数
         ;设置起始LBA扇区号
         inc dx                          ;0x1f3
         pop eax
         out dx,al                       ;LBA地址7~0

         inc dx                          ;0x1f4
         mov cl,8
         shr eax,cl
         out dx,al                       ;LBA地址15~8

         inc dx                          ;0x1f5
         shr eax,cl
         out dx,al                       ;LBA地址23~16

         inc dx                          ;0x1f6
         shr eax,cl
         or al,0xe0                      ;第一硬盘  LBA地址27~24
         out dx,al

         inc dx                          ;0x1f7
         mov al,0x20                     ;读命令
         out dx,al

  .waits:
         in al,dx
         and al,0x88
         cmp al,0x08
         jnz .waits                      ;不忙，且硬盘已准备好数据传输 

         mov ecx,256                     ;总共要读取的字数
         mov dx,0x1f0
  .readw:
         in ax,dx
         mov [ebx],ax
         add ebx,2
         loop .readw

         pop edx
         pop ecx
         pop eax
      
         ret

;-------------------------------------------------------------------------------
make_gdt_descriptor:                     ;构造描述符
                                         ;输入：EAX=线性基地址
                                         ;      EBX=段界限
                                         ;      ECX=属性（各属性位都在原始
                                         ;      位置，其它没用到的位置0） 
                                         ;返回：EDX:EAX=完整的描述符
         mov edx,eax                     ;将32位段基地址从EAX复制一份给EDX
         shl eax,16                      ;将EAX中的32位基地址左移16次,使基地址低16位部分就位
         or ax,bx                        ;描述符前32位(EAX)构造完毕,这句指令将段界限的低16位传送到EAX的低16位,段界限在EBX中
      
         and edx,0xffff0000              ;清除基地址中无关的位,低16位
         rol edx,8                       ;令段基地址在寄存器两头就位,下一步互换
         bswap edx                       ;装配基址的31~24和23~16  (80486+)
      
         xor bx,bx                       ;先清除EBX的低16位,然后同EDX合并,这里假设EBX寄存器的高12位全是0,所以用了xor bx,bx指令
         or edx,ebx                      ;装配段界限的高4位,同EDX合并
      
         or edx,ecx                      ;装配属性,就是将ECX合并到EDX
      
         ret
      
;-------------------------------------------------------------------------------
         pgdt             dw 0
                          dd 0x00007e00      ;GDT的物理地址
;-------------------------------------------------------------------------------                             
         times 510-($-$$) db 0
                          db 0x55,0xaa
;以下是注释说明:
;所有的段在使用之前,都必须以描述符的形式在描述符表中进行定义,那么像操作系统这样的软件又怎么能够加载和执行其他程序呢?毕竟不知道这些程序都定义了哪些段,每个段多长,是什么类型
;从某种意义上来说,保护模式的工作机制对用户程序的加载和执行非但没有增加困难,反而提供了许多便利,一套能够充分说明问题的例子需要很大的代码量
;只要能够说明问题,也不一定要面面俱到,因此本章用于加载和处理用户程序的做法,不一定,甚至根本就不是操作系统采用的方法,这一点务必明了
;计算机硬件之上是软件,软件分两个层次,一是操作系统,而是应用程序,通常应用程序只关心问题的解,至于软件是怎么加载到内存的,怎么定位的,它不操心
;但是它有义务提供一些必要的信息来帮助操作系统加载自己到内存中
;相反,操作系统则必须考虑采用什么方法加载用户程序,并在适当的时候将处理器的执行流转移到用户代码中去,同时为了减轻用户程序的工作量
;操作系统还应当管理硬件,并提供大量的例程供用户程序使用,比如显示字符串,直接调用操作系统的代码就可以了,但操作系统和用户程序应当协商一种机制
;让用户程序在使用这些例程时,不必考虑和关心它们的位置
;内核不能放主引导扇区,毕竟它很大,所以计算机首先从主引导程序开始执行,主引导程序负责加载内核,并转交控制权,然后内核负责加载用户程序,并提供例程供用户程序调用
;                                               内核的结构功能和加载
;                                                     内核的结构
;内核分为4个部分,分别是初始化代码,内核代码段,内核数据段,公共例程段,主引导程序也是初始化代码的组成部分
;初始化代码用于从BIOS那里接管处理器和计算机硬件的控制权,安装最基本的段描述符,初始化最初的执行环境,然后从硬盘上读取和加载内核的剩余部分
;创建组成内核的各个内存段,初始化代码大部分位于代码清单13-1(c13_mbr.asm)
;内核的代码和数据位于代码清单13-2(c13_core.asm)中,内核代码段是在第385行定义的,用于分配内存,读取和加载用户程序,控制用户程序的执行
;
;                       内核程序的各个组成部分13-2(c13_core.asm)
;
;
;     16         内核头部数据                          ;记录了各个段的汇编位置,供加载时定位内核的各个部分,也就是告诉初始化代码如何加载内核
;
;     34         section sys_routine vstart=0        ;公用例程段,这些例程既可用于内核,也可供用户程序调用,提供各种用途和功能的子过程以简化代码的编写
;
;
;
;
;     330        section core_data vstart=0          ;内核数据段,提供了一段可读写的内存空间,供内核自己使用
;
;
;
;
;     385        section core_code vstart=0          ;内核代码段
;
;
;
;
;     599        section core_trail                  ;尾部,用于计算内核长度
;
;回到代码清单13-2的开头,第7行到第13行,用于声明常数,这是一些内存段的选择子,它们对应的描述符会在内核初始化时创建
;这些段是内核的段,供内核代码使用,对内核代码是透明的,内核代码"知道"每个段选择子的具体数值,但是段选择子的具体数值是和它们在GDT中的位置相关的
;为了不至于往后因为调整段的位置而修改程序,声明成常数是最好的
;内核文件的真正开始部分是头部,偏移量为0x00的地方是一个双字,可以通过标号core_length引用,记录了整个内核文件的大小,以字节为单位
;偏移量为0x04的地方是公用例程段的起始汇编地址,是一个双字,可以通过标号sys_routine_seg引用
;偏移量为0x08的地方是核心数据段的起始汇编地址,是一个双字,可以通过标号core_data_seg引用
;偏移量为0x0C的地方是核心代码段的起始汇编地址,是一个双字,可以通过标号core_code_seg引用
;偏移量为0x10开始的地方用于指示内核入口点,可以通过标号core_entry引用
;入口点共有6个字节,低地址部分是一个双字,指示段内偏移,将来会传送到指令指针寄存器EIP,它来自一个标号start,位于第531行
;高地址部分是一个字,指定一个内存代码段的选择子,在这里填充的是刚刚在内核代码第7行声明过的常数core_code_seg_sel=0x38
;在主引导程序加载了内核之后,从这里把处理器的控制权交给内核代码
;
;                                   内核的加载
;回到代码清单13-1(主引导程序)
;第6行和第7行声明了两个常数,分别是内核程序在硬盘上的位置,以及它将要被加载的物理内存地址,声明常数是为了修改方便
;从第9行开始,一直到第55行,是为进入保护模式做准备
;
;                           本章内存布局示意图
;                    |                           |
;                    ~                           ~
;                    |                           |
;                     ---------------------------
;                    |///////////////////////////|
;                    |///////////////////////////|
;                    |///////用户程序和数据区///////|
;                    |///////////////////////////|
;           0010 0000 ---------------------------     从1MB开始的大量空间是留给用户程序用的,具体数量取决于你安装了多少物理内存
;                    |                           |
;                    ~                           ~
;                    ~                           ~
;                    |                           |
;                     ---------------------------
;                    |///////////////////////////|
;                    |///////文本模式显示缓冲区/////|       32KB
;                    |///////////////////////////|
;                    |///////////////////////////|
;           000B 8000 ---------------------------
;                    |                           |
;                    ~                           ~
;                    ~                           ~
;                    |                           |
;                    |                           |
;                     ---------------------------
;                    |///////////////////////////|
;                    |///////////////////////////|
;                    |//////系统核心程序和数据//////|
;                    |///////////////////////////|
;                    |///////////////////////////|
;                    |///////////////////////////|
;           0004 0000 ---------------------------     内核开始加载的位置
;                    |                           |
;                    ~                           ~
;                    |                           |
;                    |                           |
;                     ---------------------------
;                    |///////////////////////////|
;                    |///////全局描述符表GDT///////|    可大可小,最大64KB,空间一定要留够
;                    |///////////////////////////|
;                    |///////////////////////////|
;           0000 7E00 ---------------------------
;                    |///////////////////////////|
;                    |///初始化代码段(主引导程序)///|    512字节
;                    |///////////////////////////|
;           0000 7C00 ---------------------------
;                    |///////////////////////////|
;                    |/////////系统核心栈段////////|     4KB内核栈
;                    |///////////////////////////|
;                    |///////////////////////////|
;           0000 6C00 ---------------------------
;                    |                           |
;                    |                           |
;                    ~                           ~
;                    ~                           ~
;和GDT一样,内核大小也是不定的,但是可以规定它的起始位置,在这里我们决定将其加载到从物理地址0x0004 0000开始的地方
;从这个地方往上直到0x0009 FFFF,都是它的地盘,取决于它到底有多大,想用多少用多少,从000A 0000往上是ROM-BIOS,硬件专有的
;第19~40行,在进入保护模式之前,主引导程序已经在全局描述符表GDT中安装了几个必要的描述符,如下图:
;             表内偏移量                                           描述符索引
;                     -----------------------------------------
;                    |     文本模式显存(000B 8000~000B FFFF)    |     0x20
;                +20  -----------------------------------------
;                    |     初始栈段(0000 6C00~0000 7C00)        |    0x18
;                +18  -----------------------------------------
;                    |     初始化代码段(0000 7C00~0000 7DFF)    |     0x10
;                +10 ------------------------------------------
;                    |    0~4GB数据段(0000 0000~FFFF FFFF)      |    0x08
;                +08  -----------------------------------------
;                    |                空描述符                  |    0x00
;                +00  -----------------------------------------
;
;第一个是用于访问0~4GB内存的数据段,内核只要具备了访问全部4GB内存空间的能力时,才能随心所欲做任何事
;第二个是初始化代码段,也就是主引导程序所在的段,进入保护模式之后,要继续执行主引导城西的后半部分代码,必须按处理器的要求为其创建描述符
;第三个是栈段,这里定义的栈在初始化过程中就要使用,而在进入内核之后,它又是内核的栈
;
;下面开始加载内核,首先初始化各个段寄存器以访问相应的内存段,第59行和60行,使DS指向全部4GB的内存空间
;第62~64行,使SS指向初始的栈空间,并初始化栈指针寄存器ESP=0,第一个数据压入时,因为栈的操作是先减ESP的值,再保存数据,如果压入的是一个字,ESP的内容为0xFFFF FFFE
;如果压入的是一个双字,则ESP=0xFFFF FFFC
;接下来是从硬盘把内核程序读入内存,67~69行,它在硬盘上的起始逻辑扇区号和物理内存地址已经由两个常数给出,分别传送到EAX和EDI寄存器
;初始化代码并不知道内核有多大,所以也就不知道要读几个扇区,不过可以先读一个扇区,因为那包含着内核的头部数据,根据这些数据就可以知道内核的总扇区数
;和以前一样,我们把读硬盘扇区的指令归拢到一起,做成可以反复调用的过程read_hard_disk_0,基本上它的工作过程和具体的代码都和从前一样,但略有不同
;首先该过程要求使用EAX来传入28位的逻辑扇区号,我们现在可以使用32寄存器,不用为16位寄存器容纳不了28位逻辑扇区号发愁
;其次这里用EBX寄存器来传入偏移地址,因为在32位模式下,可以访问全部4GB的内存,允许使用32位偏移地址
;最后一个不同之处在于每次过程返回时,会使EBX寄存器的值比原来多512,这是有意的,因为在32位模式下,内存的访问不再受64KB的限制,能够连续访问,这里每次将EBX寄存器的内容加512,目的是指向下一个内存块
;接下来是取得内核长度,并计算内核所占用的扇区数
;因为段寄存器DS指向4GB内存段,其描述符高速缓存器中的基地址是0x0000 0000,所以第75行,可以直接用EDI寄存器中的数值作为偏移量来访问内存,最终生成的线性地址在数值上和EDI寄存器的内容相同
;当前指令的功能是取得内核的总长度,因为它就位于内核偏移地址0处
;第75~77行,将取得的总字节数除以512,EAX寄存器得到内核所占用的扇区数,不过在没能整除的情况下,实际扇区数比EAX寄存器中的值多1
;但是我们要的是剩余扇区数,因为已经读了一个,为此第79~81行,先判断EDX寄存器中的余数是否为0,取决于EDX的实际内容,or指令会影响ZF标志位
;如果EDX不为0,则EAX寄存器实际上就是剩余扇区数,因为它比实际扇区数少1,相反,如果EDX为0,则EAX中的内容就是总扇区数,还要用dec指令减去1才行
;但是无论哪种情况,指令的执行流程都会到达第83行,这里的指令是:
;           or eax,eax
;这条指令是用来检查EAX寄存器,看内容是否为零,如果为零,那么内核就只占用了一个扇区,于是不再读硬盘,直接跳转到setup处执行,这种情况一般不太可能
;第87~93行,用于从硬盘读取剩余的扇区,loop指令循环读取,循环次数在ECX中,如果没有第83和84行的条件判断,而且剩余扇区数为0,那么这里的循环将执行0xFFFF FFFF+1次,显然不是我们希望的
;
;                                   安装内核的段描述符
;要使内核工作起来,首要的任务是为它的各个段创建描述符,换句话说,还要为GDT续添新的描述符,在进入保护模式之前,在第42行用指令lgdt来加载全局描述符表寄存器
;标号pgdt所指向的内存位置包含了GDT的基地址和大小,现在我们的任务是重新从标号pgdt处取得GDT的基地址,为其添加描述符,并修改大小,然后用lgdt指令重新加载一遍GDTR寄存器,使其生效
;但是,如果忽略了一件事,可能就会出问题,标号pgdt所指向的内存区域位于主引导程序内,而我们当前正在保护模式下执行主引导程序,保护模式下的代码段只是用来执行的
;是否能读出,取决于其描述符的类别字段,但是无论如何它都不能写入,对代码段实施保护的意思是通过代码段描述符不能修改段中的内容
;但不意味着通过其他描述符做不到,我们拥有一个指向全部4GB内存空间的描述符,标号pgdt所指向的内存位置不单单是在主引导程序内
;同时也是4GB内存空间的一部分,如下图所示,标号pgdt在数值上等于它距离段首的偏移量,也就是编译阶段的汇编地址,主引导程序的物理起始地址是0x0000 7C00,故pgdt在4GB段内的偏移量是0x0000 7C00+pgdt
;
;           FFFF FFFF ------------
;                    |            |
;                    ~            ~
;                    ~            ~
;                    |            |
;                    |            |
;                     ------------
;                    |            |
;                    |            |
;                    |            |
;                    |            |
;                    |            |
;                    |            |
;                    |   pgdt dw  |--------------
;                    |            |       \|/
;                    |            |
;                    |            |       pgdt
;                    |            |
;                    |            |       /|\
;          0000 7C00  ---------------------------
;                    |            |        |
;                    |            |       \|/
;                    |            |
;                    |            |       7C00
;                    |            |
;                    |            |       /|\
;                    |            |        |
;          0000 0000  ---------------------------
;
;                 通过4GB数据段访问代码段内的数据
;这样为了得到GDT的基地址,第96行     mov esi,[0x7c00+pgdt+0x02]
;在这里,指令中的表达式是在编译阶段进行的,默认的段寄存器是DS,当这条指令执行时,处理器用DS描述符高速缓存器中的32位线性基地址0x0000 0000加上用该表达式计算出的偏移量来访问内存
;现在可以创建与内核相关的其他段描述符,首先是公共例程段,如下图所示,内核头部偏移0x04处的一个双字,就是公共例程段的起始汇编地址,由于内核被加载的物理地址是由EDI寄存器指向的
;所以第99行,直接访问4GB内存段,从该偏移位置取出公共例程段的起始汇编地址
;                    |                           |
;                    ~      内核头部组成示意图      ~
;                    ~                           ~
;                    |                           |
;                    |                           |
;                     ---------------------------
;                    |                           |
;                    |      内核入口点(段:偏移)     |
;                +10 |                           |
;                     ---------------------------
;                    |                           |
;                    |     内核代码段起始汇编地址    |
;                +0C |                           |
;                     ---------------------------
;                    |                           |
;                    |     内核数据段起始汇编地址    |
;                +08 |                           |
;                     ---------------------------
;                    |                           |
;                    |     公共例程段起始汇编地址    |
;                +04 |                           |
;                     ---------------------------
;                    |                           |
;                    |         内核总长度          |
;EDI保存的是内核加载地址->                           |
;                     ---------------------------
;                    |                           |
;                    |                           |
;                    ~                           ~
;                    ~                           ~
;                    |                           |
;
;创建描述符还需要知道段界限,在内核中,各个段有着确定的先后次序,而且是紧挨着的,公共例程段的后面是内核数据段,用内核数据段的起始汇编地址减去公共例程段的起始汇编地址,在减去1,就是公共例程段的段界限
;这就是第100~102行的所做的工作,对于向上扩展的段来说,段界限在数值上等于段的长度减去1
;第103行,用公共例程段的起始汇编地址加上内核的加载地址,就是公共例程段的基地址
;在已经知道某个内存段的细节时,写出它的描述符是很容易的,但是这种清楚明白的场景并不常见,大多数场合下,段的信息只有在程序运行时才能确定
;它们都是在程序运行时根据实际情况得到的随机值,为此就需要利用指令来以不变应万变,"拼凑"出描述符,既然是灵活的方法就应该定义成过程,就是这里的make_gdt_descriptor:
;该过程需要三个参数,分别是段的线性基地址,段界限和段的属性值,段的基地址用EAX传入,段界限用EBX传入,但是只用其低20位段属性用ECX寄存器传入,各个属性位在ECX中的分布与它们在描述符高32位一样,其他和段属性无关的都清零
;因此第104行将段属性值0x0040 9800传入ECX寄存器,可以知道这是一个P=1.D=1,G=0,DPL=0,S=1,TYPE=1000的代码段描述符
;第105行调用过程创建描述符,具体创建过程如下,跳到过程make_gdt_descriptor:的代码
;首先第201~203用于构造段描述符的低32位,首先将32位段基地址从EAX复制一份给EDX,过一会儿构造描述符还要用到基地址
;描述符的低32位中,高16位是基地址,低16位是段界限,所以第202~203行将EAX中的32位基地址左移16次,使基地址低16位部分就位,然后把BX寄存器中的段界限用or指令安排就位,这样就构造完描述符的低32位
;相比之下,描述符的高32位构造起来就比较麻烦,描述符高32位标准形态是有两个基地址字段和一个段界限字段,基地址在EDX部分有备份,执行第295~207行的指令后,会使基地址在两边就位
;下图是描述符高32位的构造过程
;
;     描述符的高32位标准形态(基地址和界限)
;      ------------------------------------------------------------------------------------
;     |     段基地址31~24     |       |  段界限19~16  |                |     段基地址23~16    | 
;      ------------------------------------------------------------------------------------
;
;     EDX寄存器的最初内容
;      ------------------------------------------------------------------------------------
;     |                                    段基地址31~0                                     | 
;      ------------------------------------------------------------------------------------
;
;     and edx,0xffff0000执行后
;      ------------------------------------------------------------------------------------
;     |     段基地址31~16                         |                                         | 
;      ------------------------------------------------------------------------------------
;
;     rol edx,8执行后
;      ------------------------------------------------------------------------------------
;     |     段基地址23~16     |                                       |     段基地址31~24    | 
;      ------------------------------------------------------------------------------------
;
;     bswap edx执行后
;      ------------------------------------------------------------------------------------
;     |     段基地址31~24     |                                       |     段基地址23~16    | 
;      ------------------------------------------------------------------------------------
;                 /|\          /|\                                /|\         /|\
;                  |            |______________互换________________|            |
;                  |___________________________互换_____________________________|
;
;     xor bx,bx执行后
;      ------------------------------------------------------------------------------------
;     |  0 0 0 0 0 0 0 0 0 0 0 0 |          段界限19~16           | 0 0 0 0 0 0 0 0 0 0 0 0 | 
;      ------------------------------------------------------------------------------------
;
;第207行bswap指令是字节交换指令,在标准32位处理器上只允许32位的寄存器操作数
;接下来要在描述符的高32位中装配段界限字段,第209~210行,先清除EBX的低16位,然后同EDX合并,这里假设EBX寄存器的高12位全是0,所以用了xor bx,bx指令,实际上安全的做法是使用指令and ebx,0x000f 0000
;最后第212行将ECX寄存器中的段属性与EDX中的描述符高32位合并,至此就在EDX:EAX中得到完整的64位描述符,第214行ret指令将控制权返回调用者
;回到106~107行,ESI寄存器的内容是GDT的基地址,则两条指令访问4GB段,定位到GDT,在原先的基础上再添加一个描述符,就是刚刚创建的描述符
;从110~129行,用于安装内核数据段和内核代码段的描述符,也采用了相同的过程
;第131行修改GDT界限值,下图是内核加载完成之后的GDT布局
;
;             表内偏移                                           描述符索引
;                     -----------------------------------------
;                    |         核心代码段(位于核心数据段之后)      |   0x38
;                +38  -----------------------------------------
;                    |        核心数据段(位于公用例程段之后)       |   0x30
;                +30  -----------------------------------------
;                    |        公用例程段(起始地址0004 0000)      |   0x28
;                +28  -----------------------------------------
;                    |     文本模式显存(000B 8000~000B FFFF)    |   0x20
;                +20  -----------------------------------------
;                    |     初始栈段(0000 6C00~0000 7C00)        |   0x18
;                +18  -----------------------------------------
;                    |     初始化代码段(0000 7C00~0000 7DFF)    |    0x10
;                +10 ------------------------------------------
;                    |    0~4GB数据段(0000 0000~FFFF FFFF)      |   0x08
;                +08  -----------------------------------------
;                    |                空描述符                  |   0x00
;                +00  -----------------------------------------
;
;第136行,通过4GB的数据段访问内核的头部,用间接远转移指令从给定的入口跳转到内核执行
;在内核头部偏移0x10处是6字节的内核入口点,前面是32位段内偏移地址,后面是16位的段选择子,指向内核代码段
;在这里,段选择子直接使用固定的数值不是个好主意,往后内核有重大调整会改变描述符的次序
;
;                                           在内核中执行
;从主引导程序转移到内核之后,处理器会从第532行开始执行,因为这里是内核入口,第532和533行,初始化代码段寄存器
;第535~536行调用公共例程段内个一个过程来显示字符,该call指令属于直接远转移,指令中给出了公共例程段的选择子和段内偏移量
;显示例程位于公共例程段内,是在第37行定义的,基本上它的工作原理和原来是一样的,但也有不同之处,这里代码是32位的,字符串的地址由DS:EBX传入,过程返回时使用retf,而不是ret,则意味着必须以远过程调用的方式使用它
;put_string的内部调用了另一个过程put_char,第110~113行,movsd用于在两个内存区域间传送双字数据,一次传送4字节,不管是movsb,还是movsw,或者movsd,在16位模式下,是把由DS:SI指定的源操作数传送到由ES:DI指定的目的地
;但是在32位模式下,源和目的分别是DS:ESI和ES:EDI
;接下去显示处理器品牌信息,cpuid指令用于返回处理器的标识和特性信息,EAX用于指定要返回什么样的信息,有时候还要用到ECX,cpuid指令执行后将返回信息存放在EAX,EBX,ECX或EDX
;cpuid是在80486处理器的后期版本开始引入的,原则上在使用cpuid指令之前,需要检测处理器是否支持该指令,接着再用cpuid指令检测是否有所需功能
;在32位处理器上,原先的标识寄存器FLAGS也扩充到EFLAGS,它的ID标志位(位21)如果为0,则表示不支持cpuid指令,一般情况下不需要检测
;为了探测处理器最大能够支持的功能号,应该先用0号功能来执行cpuid指令
;     mov eax,0
;     cpuid
;处理器执行后将在EAX中返回最大可以支持的功能号,同时还在ebx,ecx和edx中返回处理器供应商的信息,对于Intel处理器来说,返回的信息如下:
;     ebx <---- 0x756E6547    对应字符串"Genu",G在BL中,其他类推
;     ecx <---- 0x49656E69    对应字符串"ineI",i在CL中,其他类推
;     edx <---- 0x6C65746E    对应字符串"ntel",n在DL,其他类推
;
;组合起来就是"GenuineIntel"
;要返回处理器的品牌信息,需要使用0x80000002~0x80000004功能号,分三次进行,该功能仅被奔腾4之后的处理器支持,所以正确的做法是先用0号功能执行cpuid指令,判断处理器是否支持,但此处没有这样做
;第539~558行,分别用3种功能号执行cpuid指令,返回三组字符串,共48个字符,依次保存在核心数据段中,起始位置是由标号cpu_brand指定的
;第381行,声明了标号cpu_brand并初始化了52字节,从处理器返回的都是现成的ASCII码
;第560~565行,现在屏幕上留出空行,在显示处理器品牌信息,然后再留空,以突出要显示的内容
;
;                                           用户程序的加载和重定位
;程序加载之前需要先显示一段字符,意思是要开始加载用户程序了,这是第567~568行的工作,字符串位于内核数据段中,第367行声明了标号message_5并初始化了字符串
;第569行用于指定用户程序的起始逻辑扇区号,在指令中直接指定数值不是一个好习惯,正确的做法是用伪指令equ声明成常数
;内核的主要任务就是加载和执行用户程序,通常这样的任务会反复进行,为了方便一般定义成可以反复调用的过程,这里也是这样做的,过程的名字叫做load_relocate_program:
;该过程位于第387行,作用是加载和重定位用户程序,它是内核代码段的一个内部过程
;
;                                   用户程序的结构
;用户程序必须符合规定的格式,才能被内核识别和加载,通常流行的操作系统会规定自己的可执行文件格式,一般都比较复杂,这是与操作系统自身的复杂性息息相关的
;现在转到代码清单c13.asm,看看用户程序的结构
;所有操作系统的可执行文件都包含文件头,这里也是这样的,在文件头内的偏移0处,是一个双字,指示了用户程序的大小,以字节为单位
;偏移量为0x04处的双字是头部的长度,以字节为单位
;偏移量为0x08处的双字是为栈保留的,和早先的做法不同,内核不要求用户程序提供栈空间,而改成由内核动态分配,以减轻用户程序编写的负担,当内核分配了栈空间之后,会把栈段的选择子填写到这里
;用户程序开始执行时,可以从这里取得选择子以初始化自己的栈
;偏移量为0x0c处的双字是要求分配的栈大小,即用户程序编写者建议的栈大小,以4KB为单位,如果是1就是希望分配4KB的空间,2是8KB,以此类推
;偏移量为0x10处的双字,是用户程序入口点的32位偏移地址
;偏移量为0x14处的双字是用户程序代码段的起始汇编地址,当内核完成对用户程序的加载和重定位后,将把该段的选择子回填到这里,仅占用低字部分
;这样一来,它和0x10处的双字一起,共同组成一个6字节的入口点,内核从这里转移控制到用户程序
;偏移量为0x18处的双字,是用户程序代码段的长度,以字节为单位
;偏移量为0x1c处的双字,是用户程序数据段的起始汇编地址,当内核完成用户程序的加载和重定位后,将把该段的选择子回填到这里,仅占用低字部分
;偏移量为0x20处的双字,是用户程序数据段的长度,以字节为单位
;除了加载和重定位用户程序外,内核还应该提供一些例程供用户使用,操作系统提供的编程接口就是API,这是一大堆例程,需要的时候直接调用即可,问题在于,它们在操作系统内部,对任何人来说都是不可见的
;更别想知道它们的入口地址,但是call指令是需要直接或间接提供一个地址的,另一方面,即使你知道地址,调用的时候也有风险,操作系统也需要升级换代,地址可能改变
;为了使开发人员能够利用它所提供的API,操作系统至少要公开它们,在早期的系统中,这些API以中断号的方式公布,因为它们是经过软中断进入的
;不过另一种常见的办法是使用符号名,比如操作系统提供一个例程,用于显示光标跟随的字符串,那么它可以公布一个符号名:     PrintString
;当然,肯定不会同时公布一个段地址和偏移地址,因为不能保证地址不会变化,在操作系统的开发手册中会列出所有符号名,符号名在高级语言里就是库函数名
;
;回到代码清单c13.asm,内核要求用户程序必须在头部偏移量为0x28处构造一个表格,并在表格中列出所要用到的符号名,每个符号名的长度是256个字节,不足部分用0x00填充,则意味着每个符号名的长度最多可以是256个字符
;在用户程序加载后,内核会分析这个表格,并将每一个符号名替换成相应的内存地址,这就是过程的重定位,为了方便,我们将该表格叫做"符号-地址检索表"(Symbol-Address Lookup Table,SALT作者自己建立的,不是标准)
;第26~36行声明了三个标号,并初始化了三个符号名,SALT可大可小,内核要知道它在哪里结束,第26行用于初始化表的项数,也就是符号名的数量,用表格总长度除以256得到
;事实上即使是大多数汇编语言,也不需要亲自构造文件头,那是链接器的工作,但是链接器是为流行的操作系统服务的,用于构建它们可以识别的可执行文件格式
;我们不想把问题搞得太复杂,,迎合"流行"所要花费的代价太大,管中窥豹点到为止就可以了
;
;                                   计算用户程序占用的扇区数
;回到代码清单c13_core.asm,用户程序的加载是在例程load_relocate_program:内进行的,该过程需要用ESI寄存器传入用户程序的起始逻辑扇区号,当过程返回,在AX寄存器内包含了指向用户头部段的选择子
;为了得到用户程序的大小,需要预先读取它的第一个扇区,第399~404行做这件事情,首先使DS指向内核数据段,然后调用读硬盘的过程,来预读用户程序,进入过程前,EAX的内容是用户程序的起始逻辑扇区号
;数据的存放地点是内核缓冲区core_buf,位于内核数据段中,是在第376行声明初始化的,在内核中开辟一段固定的空间,对于分析加工和中转数据都比较方便
;接下来的工作是计算用户程序到底占用了多少扇区,用户程序的总大小就在头部内偏移量为0x00的地方,因此第407行直接访问内核缓冲区取得这个字
;用户程序不一定是512的整数倍,也就是说最后一个扇区未必是满的,因此,如果直接除以512,可能会使结果比实际扇区少一,通常需要判断余数,根据是否为零,来决定实际的扇区数,那就不可避免要使用到判断和转移指令
;在早先的处理器中,转移指令是影响处理器速度的重要因素之一,因为它会使流水线中那些已经预取和译码的指令失效,在较晚的处理器中,普遍采用了分支预测技术,但并不能总保证预测是准的,最好的办法是尽量不使用转移指令
;为了帮助程序员部分地戒掉使用转移指令的欲望,处理器引入了条件传送指令cmovcc
;CMOVcc指令是从P6处理器族引入的,因此并非所有的处理器都支持,如果想知道确切的结果,可以先以1号功能执行cpuid指令:
;     mov eax,1
;     cpuid
;当处理器执行这两条指令后,会在EBX,ECX和EDX中返回丰富的信息,此时检查EDX的第16位,当它是1时,表明处理器支持CMOVcc指令
;条件转移指令和传送指令相结合的产物,既有条件转移指令的多样性,又执行的是传送操作,但是和mov指令不同的是,它的目的操作数只允许16位或是32位通用寄存器,源操作数只能是相同宽度的通用寄存器和内存单元
;           cmovz ax,cx             ;为零则传送
;           cmovnz eax,[0x2000]     ;不为零则传送
;           cmove ebx,ecx           ;相等则传送
;           cmovng cx,[0x1000]      ;不大于则传送
;           cmovl edx,ecx           ;小于则传送
;条件传送指令是很多的,第6章的表6-1中,列举了所有的条件转移指令,完整的CMOVcc指令列表,只需要将那些指令的首字母j换成cmov即可
;CMOVcc指令不影响EFLAGS的任何标志位,相反地,它的执行过程要依赖这些标志位,就像条件转移指令
;言归正传,为了不使用条件转移指令而又能算出用户程序实际所占用的扇区数,需要一点技巧,发现所有能被512整除的数,其最低端的9个比特都是0
;很好,第408行将用户程序的总大小从EAX寄存器传送到EBX寄存器,等于做个备份
;第409~410行,先用and指令将其最低9个比特清零,等于是去掉那些不足512字节的零头,然后再将其加上512,等于将零头凑整
;但是若本来就是512字节的整数倍,这样做无疑是多加了一个扇区,因此,第411~412行先测试EAX寄存器的最低9位,如果不全为0,则采用凑整的结果,全为0,则CMOVcc指令什么也不做依然采用用户程序原本的长度值
;
;                                   简单的动态内存分配
;下面的额工作是将用户程序从硬盘读到内存中,以前的做法是指定一个区域,比如物理地址0x10 0000,然后加载到哪里,如果要加载的程序很多,就很麻烦
;在流行的操作系统中,内存管理是一项重要而又严肃的工作,不用说也相当复杂,它要记住所有可以分配的内存,将他们分成块,这样,当要分配内存时,内存管理程序将查找并分配那些大小相符的空闲块
;当占用这些快的用户程序执行完后,还要负责回收,便于下次分配,当内存空间紧张时,内存管理程序还要负责检查那些很少被访问的块,将其中的数据换到硬盘,当这些块再次被用到时,再用同样的办法从硬盘调回内存
;但这里写一个内存管理程序太不现实,现在的需求是只需要一个简单的内存分配程序即可,就是allocate_memory:
;allocate_memory的内存分配策略非常简单,第335行,在内核数据段中声明了标号ram_alloc,并初始化了一个双字0x0010 0000,这就是可用于分配的初始内存地址,很显然这个位置正好在1MB之外
;每次请求分配内存时,allocate_memory过程仅仅是简单返回该内存单元的值,作为所分配内存的起始地址,同时将这个值加上所分配的长度,作为下次分配的起始地址写回该内存单元
;因此在进行了必要的现场压栈保护之后,第239~247行,先使段寄存器DS指向内核数据段以访问标号ram-alloc所指向的内存单元,然后计算下次可用于分配内存的起始内存地址并存放到EAX中
;最后在ECX中得到本次分配到的起始内存地址,这个值将返回调用者,当然这个过程没有检测是否超越了实际拥有的物理内存
;原则上将EAX中的值写回ram_alloc所指向的双字单元即可,不过32位计算机系统建议内存地址最好是4字节对齐的,访问速度最快,为此,在将EAX中的值写回内存之前,最好使其成为可被4整除的数,特点是最低两位为0
;第249~254行,先将EAX中的值传送到EBX备份,接着强制EBX中的地址对齐在下一个4字节边界,对齐之后的值肯定比原先的大,然后,看一看原始分配的起始地址(在EAX中)是否是4字节对齐,如果不是,就采用对齐之后的值
;原本就是4字节对齐,就采用原值,最后将值写回原来的内存单元,作为下一次内存分配的起始地址
;过程allocate_memory是用retf返回的,因此只能通过远过程调用来进入
;
;                                   段的重定位和描述符的创建
;回到load_relocate_program:
;在前面计算用户程序占用的扇区数时,已经算出了用户程序的长度,而且将其调整为可以被512整除的数,第414~415行用这个数值去调用allocate_memory过程分配内存,分配到的内存块,起始地址在ECX中
;第416行,将ECX中的内容传送到EBX中,动机是作为起始地址从硬盘加载整个用户程序
;第417行将首地址压栈保存以便以后访问用户程序头部
;第418~420行,用户程序的总长度除以512得到它所占用的扇区数
;第421行将扇区数传送到ECX用于控制后面的循环次数,用来加载整个用户程序
;第423行~424行,使DS指向4GB的内存段,这样就可以加载用户程序了
;第428~430用于循环读取硬盘以加载用户程序,读取的次数由ECX控制,加载之前其首地址已经传送到EBX了,起始逻辑扇区号在循环开始之前就已经传送到EAX寄存器了
;用户程序既然已经全部读入内存,下一步就是根据它的头部信息创建段描述符
;第433行,从栈中弹出用户程序首地址到EDI,该地址也是用户程序头部的起始地址
;第434~438行读取用户程序头部信息,根据这些信息创建头部段描述符,在主引导程序里有一个创建描述符的例程,在内核中,也编写了一个同样的例程make_seg_descriptor
;甚至所用的指令都是一样的,属于公共例程段,在第308行定义,该过程要求用EAX传入段的基地址,这是第434行的工作
;段界限由EBX传入,第435~436行,访问4GB内存段,从用户程序头部偏移0x04处取出段长度,减一后形成段界限
;第437行给出头部段的属性值,从过程返回时,EDX:EAX中包含了64位段描述符
;第439行调用公共例程段内的另一过程set_up_gdt_descriptor,把该描述符安装到GDT中
;要在GDT中安装描述符必须知道它的物理地址和大小,要知道这些信息可以使用sgdt指令,它将GDTR中的基地址和边界信息保存到指定的内存位置,该指令不影响任何标志位
;第332~333行,在内核数据段中声明了标号pgdt,并初始化了6个字节,供sgdt指令使用,低2字节用于保存GDT界限,高4字节用于保存GDT的32位物理地址
;回到例程set_up_gdt_descriptor中,第270~276行,在压栈保存了DS和ES之后,是DS指向内核数据段,紧接着使用sgdt指令取得GDT的基地址和大小
;第278~279行,是段寄存器ES指向4GB内存段以操作全局描述符表,下面的工作值计算GDT的安装地址,这个地址可以这样计算:
;先得到GDT的界限值,然后加1得到GDT的总字节数,这实际上也是新描述符在GDT内的偏移量,然后用GDT的线性地址加上这个偏移量,就是用于安装这个新描述符的线性地址
;第281行,先访问内核数据段取得GDT的界限值,这里出现了一个新指令movzx(Move with Zero-Extend),其作用是带零扩展的传送,指令格式为:
;     movzx r16,r/m8
;     movzx r32,r/m8
;     movzx r32,r/m16
;也就是说movzx指令的目的操作数只能是16位或32位寄存器,源操作数只能是8位或16位的通用寄存器,或者指向8位或16位内存单元的地址,并且目的操作数和源操作数大小是不相同的
;下面是例子:
;     movzx cx,al                   ;执行前al是0xC0,执行后cx是0x00C0
;     movzx eax,byte [0x2000]       ;处理器访问DS指向的段,从偏移地址0x2000处取得一个字节,左边添加24个0,扩展到32位,然后传送到eax
;     movzx ecx,bx                  ;指向前bx是0x55AA,执行后ECX=0x0000 55AA
;
;另一个非常有用的指令是movsx(Move with Sign-Extension),意思是带符号的传送,指令格式为:
;     movsx r16,r/m8
;     movsx r32,r/m8
;     movsx r32,r/m16
;和movzx不同的是,movsx在执行扩展时,用于扩展的比特取自源操作数的符号位,下面是例子:
;     mov al,0x08
;     movsx cx,al       ;cx=0x0008
;
;     mov al,0xf5
;     movsx ecx,al      ;ECX=0xFFFF FFF5
;
;GDT的界限是16位,允许64KB大小,8192个描述符,似乎不需要32位的EBX寄存器,事实上还是需要的,因为后面要用来计算新描述符的32位线性地址,加法指令add要求的是两个32位操作数
;第282行,将GDT的界限值加1,就是GDT的总字节数,也是新描述符在GDT内的偏移量,不过我们用的是    inc bx      而不是      inc ebx
;这是有道理的,就一般情况来说,在这里用两条指令中的哪一条都没有问题,但是如果这是计算机启动以来,第一次在GDT中安装描述符可能就会有问题,在初始状态下,也就是计算机启动之后
;这时还没有使用GDT,GDTR寄存器中的基地址为0x0000 0000,界限是0xFFFF,当GDTR寄存器的界限部分是0xFFFF时,表明GDT中还没有描述符,因此将此值加一,结果是0x1 0000,截断成0x0000
;同样的道理,因为EBX中的内容是GDT的界限值0x0000 FFFF,如果执行的是指令    inc ebx     那么ebx中的内容将会是0x0001 0000,以它作为第一个描述符的偏移量显然是不对的
;相反,如果执行的指令是  inc bx      那么因为bx寄存器只有16位,结果为0x0000,进位被丢弃,此指令执行后,EBX=0x0000 0000
;第283行,用计算出来的偏移量加上GDT的基地址,结果就是新描述符的线性地址,事实上这三行或许可以用以下方法来简单处理:
;           xor ebx,ebx
;           mov bx,[pgdt]     ;GDT界限
;           inc bx            ;GDT总字节数,也是下一个描述符偏移
;           add ebx,[pgdt+2]  ;下一个描述符的线性地址
;但是少用一条指令似乎更好
;既然已经知道新描述符应该安装在哪里,第285~286行,访问ES所指向的4GB内存段,将EDX:EAX中的64位描述符写入由EDI指向的偏移处(勘误:应该是EBX指向的)
;第288~290行,访问内核数据段,将GDT的界限值加上8,然后重新加载GDTR,使新描述符生效,GDTR中的界限值总是单数(8的整数倍减去1),包括它的初始值0xFFFF,所以每次只要加上新描述符的大小就能得到正确的界限值
;最后第292~297行根据GDT的新界限值来生成相应的段选择子,具体算法是取得GDT的当前界限值,除以8,余数丢弃
;描述符的索引是从0开始编号的,界限值总是比GDT的总字节数少1,因此界限值除以8一定会有余数7(丢弃不用),商就是我们要得到的描述符索引号,最后将索引号左移3次,留出TI位和RPL位(TI=0,指向GDT,RPL=00),这就是要生成的选择子
;第299~306行,恢复调用之前的现场,返回调用者,返回时使用retf指令,因此本过程只能通过远过程调用的方式进入
;继续回到过程load_relocate_program
;安装了用户程序头部段描述符后,第440行将该段的选择子写回用户程序头部,供用户程序在接管处理器控制权后使用,实际上在内核向用户程序转交控制权时也要用到
;第443~460行,用于重定位用户程序代码段和数据段,并创建和安装相应的描述符,整个过程都是一样的
;唯一不同的是栈段,栈所用的空间不需要用户程序提供,而是由内核动态分配的,内核分配栈段空间时,是以4KB为单位的,也就是说每次分配至少是4KB的倍数,至于到底分配多少,用户程序应该根据自己需要提出建议
;第463行,从用户程序头部偏移0x0C的地方获得一个建议的栈大小,这是一个倍率,至少应当为1,说明用户希望分配4KB的栈,如果为2,则说明用户希望分配8KB的栈,以此类推
;第464~465行,计算栈段的界限,如果栈段的粒度是4KB,那么用0xF FFFF减去倍率,就是用来创建描述符的段界限,如果用户程序建议的倍率是2,那么意味着他想创建的栈空间为8KB
;因此段的界限值为       0xF FFFF-2=0xF FFFD
;那么当处理器访问栈段时,实际使用的段界限为      0xF FFFD X 0x1000 + 0xFFF = 0xFFFF DFFF
;栈是向下扩展的,访问32位栈要使用ESP,其最大值是0xFFFF FFFF,因此ESP的值只允许在0xFFFF DFFF和0xFFFF FFFF之间变化,共8KB(应该是0xFFFF E000~0xFFFF FFFF)
;第466~469行,用4096(4KB)乘以倍率,得到所需要的栈大小,然后用这个值去申请内存,这是个32位的无符号数乘法,指令格式为    mul r/m32
;这里用EAX的值乘以另一个32位的数(可以在通用寄存器或内存单元里),在EDX:EAX中的到64位乘法结果
;注意,allocate_memory过程返回所分配内存的低端地址,和一半的数据段不同,栈描述符中的基地址,应当是栈空间的高端地址
;所以第471~473行,依次调用两个例程来生成和安装栈段描述符,注意栈的属性值,它指明了这是一个32位的栈段,粒度为4KB
;第474行,将栈段的选择子写回到用户程序头部,供用户程序在接管处理器控制权之后使用
;
;                                   重定位用户程序的符号地址
;为了使用内核提供的例程,用户程序需要建立一个符号-地址对照表(SALT),这样当用户程序加载后,内核应该根据这些符号名来回填它们对应的入口地址,则成为符号地址的重定位,就是字符串匹配和比较的过程
;为了对用户程序内的符号名进行匹配,内核也必须建立一张符号-地址对照表(SALT)
;内核的SALT表位于内核数据段中,从第338行开始,一直到357行结束,实际上这个表是可以根据需要扩展的
;如下图所示,用户程序内的SALT表,每个条目是256字节,用于容纳符号名,不足256字节的用0填充
;内核中的SALT表,每个条目则包括两部分:第一部分也是256字节的符号名,第二部分有6字节,用于容纳4字节的偏移地址和2个字节的段选择子,因为符号名是用来描述例程的,则6个字节就是例程的入口地址
;
;     ______________________内核程序_____________________________
;    |                                                         |\
;    |                                                         | \
;    |                                                         |  \
;    |                                                         |   \
;    |                                                         |    \
;    |                                                         |_____\
;    |                                                                |
;    |   |<------------262字节------------>|                           |
;    |   |<----------256字节---------->|                               |
;    |                                                                |
;    |                                                                |
;    |    --------------------------------                            |
;    |   |                            |   |                           |
;    |   |      @PrintString          | <--------6字节的例程入口地址     |
;    |   |                            |   |                           |
;    |    ---------------------------------                           |
;    |   |                            |   |                           |
;    |   |      @ReadDiskData         |   |                           |
;    |   |                            |   |                           |
;    |    ---------------------------------                           |
;    |   |                            |   |                           |
;    |   |      @TerminateProgram     |   |                           |
;    |   |                            |   |                           |
;    |    ---------------------------------                           |
;    |   |                            |   |                           |
;    |   |      @PrintDwordAsHexString|   |                           |
;    |   |                            |   |                           |
;    |    ---------------------------------                           |
;    |   |                            |   |                           |
;    |   |   ......                   |   |                           |
;    |   |                            |   |                           |
;    |    ---------------------------------                           |
;    |                                                                |
;    |                                                                |
;    |                                                                |
;    |                                                                |
;    ------------------------------------------------------------------
;
;     ______________________用户程序_____________________________
;    |                                                         |\
;    |                                                         | \
;    |                                                         |  \
;    |                                                         |   \
;    |                                                         |    \
;    |                                                         |_____\
;    |                                                                |
;    |   |<----------256字节---------->|                               |
;    |                                                                |
;    |   -----------------------------                                |
;    |  |                             |                               |
;    |  |        @PrintString         |                               |
;    |  |                             |                               |
;    |   ------------------------------                               |
;    |  |                             |                               |
;    |  |        @ReadDiskData        |                               |
;    |  |                             |                               |
;    |   ------------------------------                               |
;    |  |                             |                               |
;    |  |        @TerminateProgram    |                               |
;    |  |                             |                               |
;    |   ------------------------------                               |
;    |                                                                |
;    |                                                                |
;    |                                                                |
;    ------------------------------------------------------------------
;举个内核中的例子:
;     salt_1 db '@PrintString'
;            times 256-($-salt_1) db 0
;            dd  put_string
;            dw  sys_routine_seg_sel
;这是内核SALT表的第一个条目,它初始化了一个256字节的符号名,该名称的前12个字符是"@PrintString",因为不足256字节,所以后面填充244个0x00
;该条目的后面是先是一个双字,初始化为put_string例程的偏移地址,这就是说,PrintString其实就是put_string的别名,调用PrintString,起始是调用put_string例程
;在用户程序内,只能通过远过程调用来进入该例程,所以该条目的最后一个字,用公用例程段的选择子来初始化,因为put_string例程位于公用例程段
;在内个SALT表中,比较有意思的是最后一个条目:
;     salt_4 db  '@TerminateProgram'
;            times 256-($-salt_4) db 0
;            dd  return_point
;            dw  core_code_seg_sel
;在这里从名字可以看出,"TerminateProgram"的意思是终止程序,当用户程序调用该过程时意味着结束用户程序,将控制返回内核
;当用户程序终止并返回时,返回点位于标号return_point所在的位置,该标号位于第582行,属于内核代码段,在这一行之前,是内核将控制权交给用户程序的指令
;内核的SALT表是静态的,适用于所有要加载的用户程序,理所当然要比用户程序的SALT表大,因为它要提供所有可被用户程序调用的过程列表,至于用户程序,根据需要它只会列出自己要用到的那些
;在用户程序加载时,内核的任务是比对这两张SALT表,并将用户程序SALT表中的符号名替换成相应的入口地址,为了便于说明,用户程序的SALT表简称为U-SALT,内核的SALT表简称为C-SALT
;基本的算法是使用内外层循环,外循环依次从U-SALT取出条目,每取出一个条目就进入内循环进行比对,内循环遍历C-SALT中的每一个条目,同外循环输入的条目进行比对
;对比的过程就是两个字符串比较的过程,可以使用指令cmps指令(Compare String Operands),该指令有三种基本形式,分别用于字节,字和双字的比较
;     cmpsb       cmpsw       cmpsd
;在16位模式中,源字符串的首地址由DS:SI指定,目的字符串的首地址由ES:DI指定
;在32位模式中,源字符串的首地址由DS:ESI指定,目的字符串的首地址由ES:EDI指定
;在处理器内部,cmps指令的操作是把两个操作数相减,然后根据结果设置相应的标志位
;取决于标志寄存器中的DF位,如果DF=0,表明是正向比较,也就是按地址递增的方向比较,这些指令执行后,SI(ESI)和DI(EDI)的内容分别加1,2和4,否则DF=1,表明是反向比较,这些指令执行后,SI(ESI)和DI(EDI)的内容分别减1,2和4
;单纯的cmps指令只比较一次,属于推一下动一下的类型,所以需要加指令前缀rep进行连续的比较,连续比较的次数由CX(ECX)控制,在16位模式下,使用CX寄存器,32位模式下使用ECX寄存器
;     [bit 32]
;     rep cmpsd
;该指令执行时,每次比较4个字节,连续比较直至ECX为零
;问题是使用rep前缀连续比较也比较不出个所以然来,看不出两个字符串哪里不同,所以针对cmps指令,应当使用repe(repz)和repne(repnz)前缀,前者是若相等(为零)则重复,后者是若不等(非零)则重复
;但无论是哪种情况,总的比较次数由CX(ECX)控制,下标显示了这几种控制手段的区别
;                       重复前缀
;     -----------------+-----------------+-----------------
;    |      重复前缀    |     终止条件一    |     终止条件二    |
;             rep            (E)CX=0              无
;          repz/repe         (E)CX=0             ZF=0
;         repnz/repne        (E)CX=0             ZF=1
;
;可见,repe/repz用于搜索第一个不匹配的字节,字或双字
;repne/repnz用于搜索第一个匹配的字节,字或双字
;无论如何,匹配和不匹配的位置分别由(E)SI和(E)DI指示
;回到代码清单c13_core.asm,如下图所示,为了重定位U-SALT,我们打算用DS:ESI指向C-SALT,用ES:EDI指向U-SALT
;第477~478行,访问4GB内存段,从用户程序头部偏移为0x04的地方取出刚刚安装好的头部段选择子,并ES指向用户程序头部段,因为U-SALT在用户程序头部段内
;第479~480行,使DS指向内核数据段,因为C-SALT在内核数据段中
;第482行,清标志寄存器的方向标志,使cmps按正向比较
;比较算法前面已经介绍过了,外循环的作用是依次从U-SALT取出各个条目,因此第484行将取的次数(条目的个数)从用户程序头部取出传送到ECX
;接着第485行,用于将U-SALT在头部段内的偏移量传送到EDI,前面已经使用ES指向了头部段
;
;                  ----------------                 U-SALT和C-SALT的对比过程
;                 |                |
;                 |                |<-----------                                 -----------
;                 |                |            \                         /|\   |           |
;                 |     内核程序    |<------------\                         |    |   用户程序  |
;                 |     C-SALT     |              \                        |    |   U-SALT  |
;                 |                |<--------------\                       |    |           |
;                 |                |                \                      |    |           |
;                 |                |<----------------\逐个比较 <-----------------|           |
;                 |                |                 /            ES:EDI-------->-----------
;                 |                |<---------------/
;                 |                |               /
;                 |                |<-------------/
; DS:ESI---------> ----------------
;由于内循环也要用到ECX和EDI寄存器,并可能破坏内容,因此在进入内循环之前先对它们进行压栈保护,以便退出内循环后继续使用
;外循环的任务是从U-SALT中依次取出表项,因此当内循环完成比对之后,第512~513行从栈中弹出EDI的原始内容,并加上256以指向U-SALT下一个条目
;第514~515行,从栈中弹出ECX的原值,loop指令将ECX的内容减去1,根据结果判断是否继续循环
;对于外循环所指向的每一个条目,内循环要用它和C-SALT中的所有条目进行比对,详情见内循环的代码
;每次从外循环进入内循环时,都要重新设置比对次数,并重新使ESI指向C-SALT的开始处,的是第490~491所做的工作
;标号salt_item_len是在第359行声明的,并用一个表达式初始化,每个条目的长度都是相同的,用当前汇编地址减去标号salt_4的汇编地址,即$-salt_4,就是每个条目的长度(字节数)
;事实上这个数值是在编译阶段由编译器计算的,等于262
;标号salt_items是在第360行声明的,并初始化为一个表达式,意思是用整个C-SALT的长度,除以每个条目的长度,就是条目的个数
;对于内循环的每一次执行,都要把ESI,EDI和ECX压栈保护,每次对比结束后,第506~509行依次弹出这些寄存器的值,并把ESI的内容加上C-SALT每个条目的长度262字节,以指向下一个C-SALT条目
;第510行,loop指令执行时,将ECX的内容减1并判断是否继续循环
;第497~503行,是整个比对过程的核心部分,每当处理器执行到这里时,DS:ESI和ES:EDI都各自指向C-SALT和U-SALT中的某个条目
;因为每个条目的符号名部分是256字节,每次用cmpsd指令比较4个字节,故每个条目至多需要比对64次,第497行把立即数64传入ECX以控制整个比较过程
;第498行,开始比对直到发现一个不相符的地方
;如果两个字符串相同,则需要连续比对64次,而且在比对结束时,ZF=1,表示最后4个字节也相同
;如果两个字符串不相同,对比过程会提前结束,且ZF=0,在最坏情况下,这两个字符串可能只有最后4字节是不同的,在这种情况下也需要比对64次,但ZF=0
;无论哪种情况,如果在退出      repe cmpsd 指令时ZF=0,即表明两个字符串是不同的,所以第499行,如果ZF=0,则表明两个字符串不同,直接转移到内循环的末尾,开始下一次内循环
;如果两个字符串是相同的,那么比较执行后,ESI正好指向C-SALT每个条目后的入口数据,要知道,C-SALT中的每个条目是262字节,最后6字节分别是偏移地址和段选择子
;因此现在的任务是将这结尾的6字节传送到U-SALT当前条目的开始部分,这是第500~503行做的
;最后结果是U-SALT中的当前条目,其开始的6字节被改写成为一个入口地址
;
;                                         执行用户程序
;在load_relocate_program过程的最后,第517行,把用户程序头部段的选择子传送到AX寄存器
;第519~528行,从栈中弹出并恢复各个寄存器的原始内容,并返回调用者,AX寄存器中的选择子是作为参数返回到主程序的,主程序将用它来找到用户程序的入口,并从那里进入
;从load_relocate_program过程返回后,第572~573行用于在屏幕上显示信息,表示加载和重定位已经完成
;第575行,保存内核的栈指针,这是通过将ESP寄存器的当前值写入内核数据段中来完成的,写入位置由标号esp_pointer指示的,位于第378行,初始化为一个双字
;在进入用户程序后,用户程序应当切换到自己的栈,从用户程序返回时,还要从这个内存位置还原内核栈指针
;第577行,将用户程序头部段选择子传送到DS,使DS指向用户程序头部,在用户程序头部段内偏移0x10处,是用户程序的入口点,分别是32位的偏移量和16位的代码段选择子
;第579行,执行一个间接远转移,进入用户程序内接着执行
;
;现在转到代码清单c13.asm
;用户程序入口点是在第56行,进入用户程序开始执行时,段寄存器DS是指向头部段的,第57~58行,使段寄存器FS指向头部段,因为后面要调用内核过程,而这些过程都要求使用DS,所以把DS解放出来
;第60~62行,切换到用户程序自己的栈,并初始化ESP=0
;第64~65行,设置DS到用户程序自己的数据段
;第67~68行,调用内核过程显示字符串,以表明用户程序正在运行中,该内核过程要求用DS:EBX指向零终止的字符串
;第70~72行,调用内核过程,从硬盘读一个扇区到自己数据段中的缓冲区,ReadDiskData过程的内部名称是read_hard_disk_0
;所以ReadDiskData需要传入两个参数,第一是EAX寄存器传入要读的逻辑扇区号,第二是DS:EBX传入缓冲区的首地址
;缓冲区位于用户程序的数据段中,是在第43行用标号buffer声明的,并初始化了1024个字节,要读的逻辑扇区号是100,在此之前应当在这个扇区里写一些东西,下面马上讲到
;第74~78行,先调用内核过程显示一个题头,接着再次调用内核过程显示刚刚从硬盘读出的内容,在做完上述事情后,用户程序的任务也就完成了
;第80行,调用内核过程返回内核,其实这个返回内核过程的信息就是内核代码段中加载及重定位用户程序并跳转到用户程序内执行的那条语句的后面的标号,过程就是一个标号
;
;回到内核代码中,在内核中,用户程序的返回点位于第582行
;在重新接管了处理器的控制权后,第583~584行使DS重新指向内核数据段
;第586~588行,切换栈,使栈段寄存器SS重新指向内核栈段,并从内核数据段中取得和恢复原先的栈指针位置
;第590~591行,显示一条消息,表示现在已经回到内核
;对于一个操作系统来说,下面的任务是回收前一个用户程序所占用的内存,并启动下一个用户程序,但是现在我们无事可做
;所以第596行,使处理器进入停机状态,别忘了在进入保护模式之前,我们用 cli指令关闭了中断,所以除非由NMI产生,处理器将一直处于停机状态
;
;                                               代码的编译,运行和调试
;将c13_mbr.asm,c13_core.asm和c13.asm编译生成c13_mbr.bin,c13_core.bin和c13.bin,分别写入起始逻辑扇区号0,起始逻辑扇区号1,起始逻辑扇区号50
;除了c13_mbr.bin外,其他文件的写入位置可以改变,前提是要修改使用它们的源代码
;用户程序的功能是读取逻辑扇区100,并显示其内容,,为此需要找一个文本文件写入该扇区,在配书源代码中,提供了一个文本文件diskdata.txt,大小是512字节
;不一定要用这个文件,可以选用其他文件(貌似和书上不符合啊,命名写入文件了还是不行啊,用户程序不是读写100扇区这个功能)
;如果你采用的是其他文件,会连续写入多个扇区,这无所谓,用户程序只会读取第一个扇区
;
;随着代码量的增加,程序的编写和调试也会变得更加困难,这里写了一个特殊的过程,用来显示某个寄存器的内容
;如果程序在运行时出了问题,可以在有重大嫌疑的指令前后安排一些调用该过程的代码,看看哪里不正常,这些用于调试程序的位置,叫做检查点
;为了方便调试程序,代码清单c13_core.asm提供了一个过程put_hex_dword,用于以十六进制的形式显示EDX寄存器的内容
;该过程位于第202行,它的工作原理很简单,EDX是32位的,从右至左,将它以4位为一组,分成8组,每一组的值都在0~15之间,将其转换成相应的字符即可
;为了将数值转换成可显示的ASCII码,可以使用处理器的查表指令   xlat(Table Look-up Translation),该指令不影响任何标志位
;该指令要求事先在DS:(E)BX处定义一个用于转换编码的表格,指令执行时,处理器访问该表格,用AL寄存器的内容作为偏移量,从表格中取出一字节,传回AL寄存器
;定义的表格在第374行,声明了标号bin_hex,并初始化了16个字符,这是一个二进制到十六进制的对照检索表,偏移(索引)为0的位置是字符0,0x0f的位置是字符F
;第209~210行,使DS指向内核数据段,因为对照表位于内核数据段中
;第212行,使EBX指向对照检索表的起始处
;转换过程使用了循环,每次将EDX的内容循环左移4位,共需循环8次,每次移位后的内容被传送到EAX中,并用and指令保留低4位,高位清零
;第218行,xlat指令用AL中的值作为索引访问对照表,取出相应的字符并回传到AL
;每次从对照表中得到一个字符,就要调用put_char过程显示它,但put_char过程需要使用CL作为参数,因此第220行,在显示之前先要将ECX压栈保护