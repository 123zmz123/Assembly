     1                                           ;代码清单5-1 
     2                                           ;文件名：c05_mbr.asm
     3                                           ;文件说明：硬盘主引导扇区代码,0x012E(十进制302)
     4                                           ;创建日期：2011-3-31 21:15 
     5                                           
     6 00000000 B800B8                           mov ax,0xb800                 ;指向文本模式的显示缓冲区,0xB8000~0xBFFFF这段物理地址空间是留给显卡的
     7 00000003 8EC0                             mov es,ax                     ;设置段地址到附加段寄存器es
     8                                  
     9                                           ;以下显示字符串"Label offset:"
    10 00000005 26C60600004C                     mov byte [es:0x00],'L'        ;第一个字节对应屏幕左上角第一个字符,我们只负责传入ASCII码,其余事情由字符发生器及控制电路完成显示
    11 0000000B 26C606010007                     mov byte [es:0x01],0x07       ;第二个字节对应屏幕左上角第一个字符的显示属性KRGBIRGB,K闪烁位,I亮度位
    12 00000011 26C606020061                     mov byte [es:0x02],'a'
    13 00000017 26C606030007                     mov byte [es:0x03],0x07
    14 0000001D 26C606040062                     mov byte [es:0x04],'b'
    15 00000023 26C606050007                     mov byte [es:0x05],0x07
    16 00000029 26C606060065                     mov byte [es:0x06],'e'
    17 0000002F 26C606070007                     mov byte [es:0x07],0x07
    18 00000035 26C60608006C                     mov byte [es:0x08],'l'
    19 0000003B 26C606090007                     mov byte [es:0x09],0x07
    20 00000041 26C6060A0020                     mov byte [es:0x0a],' '
    21 00000047 26C6060B0007                     mov byte [es:0x0b],0x07
    22 0000004D 26C6060C006F                     mov byte [es:0x0c],"o"
    23 00000053 26C6060D0007                     mov byte [es:0x0d],0x07
    24 00000059 26C6060E0066                     mov byte [es:0x0e],'f'
    25 0000005F 26C6060F0007                     mov byte [es:0x0f],0x07
    26 00000065 26C606100066                     mov byte [es:0x10],'f'
    27 0000006B 26C606110007                     mov byte [es:0x11],0x07
    28 00000071 26C606120073                     mov byte [es:0x12],'s'
    29 00000077 26C606130007                     mov byte [es:0x13],0x07
    30 0000007D 26C606140065                     mov byte [es:0x14],'e'
    31 00000083 26C606150007                     mov byte [es:0x15],0x07
    32 00000089 26C606160074                     mov byte [es:0x16],'t'
    33 0000008F 26C606170007                     mov byte [es:0x17],0x07
    34 00000095 26C60618003A                     mov byte [es:0x18],':'
    35 0000009B 26C606190007                     mov byte [es:0x19],0x07
    36                                  
    37 000000A1 B8[2E01]                         mov ax,number                 ;取得标号number的偏移地址,编译时将number转化为立即数0x012E(十进制302)
    38 000000A4 BB0A00                           mov bx,10                     ;10作为除数传到bx中
    39                                  
    40                                           ;设置数据段的基地址,令数据段和代码段指向同一个段,可以使用段超越前缀cs:,但习惯上使用数据段访问更自然
    41 000000A7 8CC9                             mov cx,cs
    42 000000A9 8ED9                             mov ds,cx
    43                                           ;8086处理器提供两种除法,第一种类型用16位的二进制数除以8位的二进制数,被除数必须事先传送到ax中,除数可以由8为寄存器或内存单元提供,div指令执行后,余数在ah,商在al
    44                                           ;求个位上的数字
    45 000000AB BA0000                           mov dx,0                      ;把0传到dx中,意味着将dx:ax作为被除数(第二种除法使用32位二进制数除以16位二进制数,8086是16位处理器,无法直接提供32位的被除数,要求被除数的高16位在dx中,低16位在ax中,除完商在ax中,余数在dx中),即被除数的高16位全为0,至于低16位,已经在第37行的代码中被设置为标号number的汇编地址
    46 000000AE F7F3                             div bx
    47 000000B0 8816[2E7D]                       mov [0x7c00+number+0x00],dl   ;保存个位上的数字,主引导扇区被加载到内存并开始执行时,cs=0x0000,ip=0x7c00,BIOS部分的jmp 0x0000:0x7c00,将会使得cs=0x0000,间接使得ds=0x0000
    48                                  
    49                                           ;求十位上的数字
    50 000000B4 31D2                             xor dx,dx                     ;异或dx,相当于清零dx,不使用传0进去dx是因为这样做不仅仅指令短且速度快,因为余数在dx,所以相当于重置被除数为上一次的商
    51 000000B6 F7F3                             div bx
    52 000000B8 8816[2F7D]                       mov [0x7c00+number+0x01],dl   ;保存十位上的数字
    53                                  
    54                                           ;求百位上的数字
    55 000000BC 31D2                             xor dx,dx
    56 000000BE F7F3                             div bx
    57 000000C0 8816[307D]                       mov [0x7c00+number+0x02],dl   ;保存百位上的数字
    58                                  
    59                                           ;求千位上的数字
    60 000000C4 31D2                             xor dx,dx
    61 000000C6 F7F3                             div bx
    62 000000C8 8816[317D]                       mov [0x7c00+number+0x03],dl   ;保存千位上的数字
    63                                  
    64                                           ;求万位上的数字 
    65 000000CC 31D2                             xor dx,dx
    66 000000CE F7F3                             div bx
    67 000000D0 8816[327D]                       mov [0x7c00+number+0x04],dl   ;保存万位上的数字
    68                                  
    69                                           ;以下用十进制显示标号的偏移地址
    70 000000D4 A0[327D]                         mov al,[0x7c00+number+0x04]
    71 000000D7 0430                             add al,0x30
    72 000000D9 26A21A00                         mov [es:0x1a],al
    73 000000DD 26C6061B0004                     mov byte [es:0x1b],0x04
    74                                           
    75 000000E3 A0[317D]                         mov al,[0x7c00+number+0x03]
    76 000000E6 0430                             add al,0x30
    77 000000E8 26A21C00                         mov [es:0x1c],al
    78 000000EC 26C6061D0004                     mov byte [es:0x1d],0x04
    79                                           
    80 000000F2 A0[307D]                         mov al,[0x7c00+number+0x02]
    81 000000F5 0430                             add al,0x30
    82 000000F7 26A21E00                         mov [es:0x1e],al
    83 000000FB 26C6061F0004                     mov byte [es:0x1f],0x04
    84                                  
    85 00000101 A0[2F7D]                         mov al,[0x7c00+number+0x01]
    86 00000104 0430                             add al,0x30
    87 00000106 26A22000                         mov [es:0x20],al
    88 0000010A 26C606210004                     mov byte [es:0x21],0x04
    89                                  
    90 00000110 A0[2E7D]                         mov al,[0x7c00+number+0x00]
    91 00000113 0430                             add al,0x30
    92 00000115 26A22200                         mov [es:0x22],al
    93 00000119 26C606230004                     mov byte [es:0x23],0x04
    94                                           
    95 0000011F 26C606240044                     mov byte [es:0x24],'D'
    96 00000125 26C606250007                     mov byte [es:0x25],0x07
    97                                            
    98 0000012B E9FDFF                     infi: jmp near infi                 ;无限循环,infi是标号,由字母数字_$#@!.?组成,必须以字母._?任意一个开头,near表示目标位置还在当前代码段内
    99                                        
   100 0000012E 0000000000                number db 0,0,0,0,0                  ;伪指令db声明5个字节变量并初始化,number是标号代表这些数据的起始汇编地址,没有冒号无关紧要
   101                                    
   102 00000133 00<rept>                  times 203 db 0                       ;times指令用于重复后面的指令若干次
   103 000001FE 55AA                                db 0x55,0xaa               ;有效的引导扇区以0x55和0xAA结尾标记也可以使用dw 0xaa55因为在Intel处理器上采用低端字节序,低字节在低地址端,高字节在高地址端
;8086处理器取指令时,把cs内容左移4位,加上ip的内容,形成20位的物理地址,取得指令然后执行,同时把ip加上当前之类的长度指向下一条指令的偏移地址
;在8086处理器的系统中,ROM占据着顶端的64KB,0xF0000~0xFFFFF,里面固化了开机时要执行的指令,DRAM占据着较低端的640KB,0x00000~0x9FFFF,中间部分分配给其他外围设备
;8086处理器加电复位时,cs=0xFFFF,ip=0x0000,所以第一条指令位于物理地址0xFFFF0处,正好位于ROM中,那里固化了开机时要执行的指令
;和8086不同,现代处理器在加电启动时,cs=0xF000,ip=0xFFF0,这就使得处理器地址线的低20位依旧是0xFFFF0,这还没完,处理器还将其余高位地址线强制高电平直到遇见并执行第一个段间转移指令(在两个代码段之间实施控制转移,同时改变cs和ip),所以Bochs虚拟机初始发出的物理内存地址为0x00000000FFFFFFF0
;之所以这样做是因为处理器设计者希望将ROM-BIOS放到4GB(32根地址线的寻址范围)内存的最顶端,这样,4GB连同传统的低端1MB都是连续的RAM区,且老的硬件和软件依赖于低端的1MB,这样做就可以使得这两个地址区段都指向同一个ROM芯片
;处理器取指令自然是从低地址往高地址推进,如果从0xFFFF0开始执行,这个位置离1MB的顶端仅仅有16个字节,所以,ROM中位于物理地址0xFFFF0的地方,通常是一个跳转指令,这个指令通过改变cs和ip的内容
;使处理器从ROM的较低地址处开始取指令执行,还是在ROM中,还是在ROM中,还是在ROM中
;当ROM-BIOS完成自己的使命后,最后要做的事情是从外存储设备读取更多的指令来交给处理器执行,如果设置硬盘为首选的外存储设备,那么,ROM-BIOS将读取硬盘上的主引导扇区(0道0面1扇区)
;将它加载到内存地址0x0000:0x7c00处(物理地址0x07c00处),然后用一个jmp 0x0000:0x7c00直接绝对转移指令跳转到那里继续执行
;这时候cs还是等于0x0000,所以这就解释了第47行代码mov [0x7c00+number+0x00],dl   ;保存个位上的数字,主引导扇区被加载到内存并开始执行时,cs=0x0000,ip=0x7c00,BIOS部分的jmp 0x0000:0x7c00,将会使得cs=0x0000而不是0x7c00
;又因为将ds的内容设置为跟cs一样,所以指令执行时处理器将段寄存器ds左移4为加上偏移地址
;infi: jmp near infi
;实际上这是一个3字节指令,操作码为0xE9,后跟一个16位(2字节)的操作数,该操作数并非是目标位置的偏移地址,而是目标位置相对于当前指令处的偏移量(以字节计)
;相对偏移量,用标号处的汇编地址减去当前指令的汇编地址,再减去当前指令的长度得到
;在编译阶段编译器是这么做的:用标号(目标位置)处的汇编地址减去当前指令的汇编地址,再减去当前指令的长度3(-3是因为这一指令一执行ip就会加上3,导致要跳转的标号地址与当前指令的起始地址相对量多出3),就得到jmp near infi指令的实际操作数,这里实际操作数是-3
;编译器是如何区分这两种不同的转移方式?当它看到jmp之后是一个绝对地址时,就编译成使用操作码为0xEA的直接绝对转移指令
;相反它发现jmp之后是一个标号,就编译成使用操作码为0xE9的相对转移指令,关键字near不是最主要的,它仅仅用于指示相对量是16位的
;在这里,目标位置就是当前指令自己的位置,间隔的长度为0,0减去当前指令的长度3位负数-3
;使用二进制0减去二进制11会发现结果是...1111111111111101(这样理解补码将更加直观)
;由于使用near,将只保留16位,即0xFFFD
;这条指令需要的实际操作数为-3,在指令执行阶段,处理器用ip寄存器加上该指令的操作数,再加上该指令的长度3,就得到了要转移的实际偏移地址,同时cs不变
;因为改变了ip将导致处理器的执行流程转向目标位置
;当infi: jmp near infi指令执行时,转移到的目标位置是ip+0xFFFD(实际操作数-3)+3(当前指令长度3),然后0xFFFD+3=0x10000,截断后就等于0x0000,所以ip不变,再次执行自己
;内存分配情况
;       ________________
;FFFFF |    ROM-BIOS    |
;      |      64KB      |
;F0000 |                |
;       ----------------
;      |                |
;      |                |
;      |                |
;      |                |
;      |                |
;      |                |
;BFFFF  ----------------
;      |  显存-映射到显卡 |     将要显示的字符的ASCII码写入显存,其余工作由字符发生器完成
;      |     32KB       |
;B8000  ----------------
;      |                |
;      |                |
;      |                |
;A0000  ----------------
;      |                |
;      |                |
;      |                |
;      |                |
;      ~     640KB      ~
;      ~                ~
;      |                |
;      |                |
;      |                |
;      |                |
;      |                |
;00000  ----------------