         ;代码清单12-1
         ;文件名：c12_mbr.asm
         ;文件说明：硬盘主引导扇区代码 
         ;创建日期：2011-10-27 22:52

         ;设置堆栈段和栈指针 
         mov eax,cs      
         mov ss,eax
         mov sp,0x7c00
;32位处理器在实模式下也可以使用32位寄存器
         ;计算GDT所在的逻辑段地址
         mov eax,[cs:pgdt+0x7c00+0x02]      ;GDT的32位线性基地址传送到32位寄存器EAX 
         xor edx,edx                        ;清零32位寄存器EDX
         mov ebx,16                         ;分解成16位逻辑地址
         div ebx                            ;EAX中的商是段地址,仅低16位有效,EDX中的余数是偏移地址,仅低16位有效
         ;初始化段寄存器DS使其指向GDT所在的段
         mov ds,eax                         ;令DS指向该段以进行操作
         mov ebx,edx                        ;段内起始偏移地址 

         ;创建0#描述符，它是空描述符，这是处理器的要求
         mov dword [ebx+0x00],0x00000000
         mov dword [ebx+0x04],0x00000000  

         ;创建1#描述符，这是一个数据段，对应0~4GB的线性地址空间
         mov dword [ebx+0x08],0x0000ffff    ;基地址为0，段界限为0xffff f
         mov dword [ebx+0x0c],0x00cf9200    ;粒度为4KB，存储器段描述符 

         ;创建保护模式下初始代码段描述符
         mov dword [ebx+0x10],0x7c0001ff    ;基地址为0x00007c00，512字节 
         mov dword [ebx+0x14],0x00409800    ;粒度为1个字节，代码段描述符,9800的8是TYPE只执行

         ;创建以上代码段的别名描述符
         mov dword [ebx+0x18],0x7c0001ff    ;基地址为0x00007c00，512字节
         mov dword [ebx+0x1c],0x00409200    ;粒度为1个字节，数据段描述符,9200的2是TYPE读写

         mov dword [ebx+0x20],0x7c00fffe    ;基地址为0x00007c00,段界限0xF FFFE,粒度4KB,因为用于栈段,B位=1,使用ESP,读写,向下扩展
         mov dword [ebx+0x24],0x00cf9600
         
         ;初始化描述符表寄存器GDTR
         mov word [cs: pgdt+0x7c00],39      ;描述符表的界限,设置GDT的界限值为39,共5个描述符,40字节,界限值39
 
         lgdt [cs: pgdt+0x7c00]
      
         in al,0x92                         ;南桥芯片内的端口 
         or al,0000_0010B
         out 0x92,al                        ;打开A20

         cli                                ;中断机制尚未工作

         mov eax,cr0
         or eax,1
         mov cr0,eax                        ;设置PE位
      
         ;以下进入保护模式... ...
         jmp dword 0x0010:flush             ;16位的描述符选择子：32位偏移
                                            ;段选择子的组成:
         [bits 32]                          ;15                          3   2  1    0
  flush:                                    ;|          描述符索引          | TI | RPL |
         mov eax,0x0018                     ;0000 0000 0001              1   0    00    索引号为3
         mov ds,eax                         ;段选择子表明要加载的是索引号为3的描述符
      
         mov eax,0x0008                     ;加载数据段(0:4GB)选择子
         mov es,eax                         ;;0000 0000 0000              1   0    00   索引号为1
         mov fs,eax                         ;段选择子表明要加载的是索引号为1的描述符
         mov gs,eax
      
         mov eax,0x0020                     ;0000 0000 0010              0   0    00    索引号为4
         mov ss,eax                         ;段选择子表明要加载的是索引号为4的栈段描述符
         xor esp,esp                        ;清零ESP,也就是ESP <- 0
      
         mov dword [es:0x0b8000],0x072e0750 ;字符'P'、'.'及其显示属性
         mov dword [es:0x0b8004],0x072e074d ;字符'M'、'.'及其显示属性
         mov dword [es:0x0b8008],0x07200720 ;两个空白字符及其显示属性
         mov dword [es:0x0b800c],0x076b076f ;字符'o'、'k'及其显示属性

         ;开始冒泡排序 
         mov ecx,pgdt-string-1              ;遍历次数=串长度-1,用后面的标号pgdt减去前面的标号string,就是字符串的长度,再减去1,就是控制循环次数
  @@1:
         push ecx                           ;32位模式下的loop使用ecx 
         xor bx,bx                          ;清零bx,用于从字符串开头开始比较,不使用ebx是因为32位代码中也可以使用16位寄存器来寻址
  @@2:                                      ;32位模式下，偏移量可以是16位，也可以是后面的32位
         mov ax,[string+bx]                 ;一次性读取两个字符到ax中
         cmp ah,al                          ;ah中存放的是源字的高字节(后一个字符),al存放的是低字节(前一个字符)
         jge @@3                            ;jge表示大于等于,如果前一个字符较大,则交换ah和al,也就是条件不成立,不跳转
         xchg al,ah                         ;xchg是交换指令,用于交换两个操作数的内容,源操作数和目的操作数都可以是8/16/32位的寄存器,或者指向8/16/32位实际操作数的内存单元地址,但不允许同为内存地址
         mov [string+bx],ax                 ;交换ah和al后写回原来的内存单元,然后将bx加1,指向下一个字符
  @@3:
         inc bx                             ;将bx加1
         loop @@2                           ;回到内循环比较
         pop ecx                            ;比较完恢复外层循环控制ecx
         loop @@1                           ;回到外层循环
;93~100行用于显示最终排序结果,循环次数是字符串长度,现在使用EBX,提供32位偏移地址      
         mov ecx,pgdt-string
         xor ebx,ebx                        ;偏移地址是32位的情况 
  @@4:                                      ;32位的偏移具有更大的灵活性,可以在基址寄存器上使用比例因子,使用比例因子时,表达式的值由处理器计算
         mov ah,0x07
         mov al,[string+ebx]                ;[es:0xb80a0+ebx*2],该表达式的值是在处理器执行时,由来处理器计算
         mov [es:0xb80a0+ebx*2],ax          ;演示0~4GB寻址,段寄存器ES是刚进入保护模式时设置的,指向0~4GB内存的段
         inc ebx                            ;0xb80a0等于0xb8000加上0xa0(十进制160)得到的,对应着屏幕第二行第一列
         loop @@4
      
         hlt                                ;使处理器停机

;-------------------------------------------------------------------------------
     string           db 's0ke4or92xap3fv8giuzjcy5l1m7hd6bnqtw.'
;-------------------------------------------------------------------------------
     pgdt             dw 0
                      dd 0x00007e00      ;GDT的物理地址
;-------------------------------------------------------------------------------                             
     times 510-($-$$) db 0
                      db 0x55,0xaa
;以下是注释说明:
;处理器引入保护模式是为了提供保护功能,很重要的一方面是存储器保护,存储器保护可以禁止程序的非法内存访问,在程序失去控制之前引发异常中断
;凡事都有两面性,利用存储器保护功能,可以实现一些有价值的功能,比如虚拟内存管理,当处理器访问一个实际上不存在的段时,会引发异常中断,操作系统可以利用这一点,通过接管
;异常处理过程,并用硬盘来进行段的换入和换出,从而实现较小的内存运行尽可能大,尽可能多的程序
;
;                               关于指令前缀
;段寄存器(选择器)的值只能用内存单元或通用寄存器来传送,一般指令格式是    mov sreg,r/m16
;常见   mov ds,ax   在16位模式下,传送到ds的是逻辑段地址,32位保护模式下,传送的是段描述符选择子,无论传送的是什么,都不重要,重要的是在16位和32位模式下
;一些老式的编译器会产生不同的机器码,如下
;       [bit 16]
;       mov ds,ax   ;8E D8
;
;       [bit 32]
;       mov ds,ax   ;66 8E D8
;
;由于在16位模式下,默认的操作数大小是2字节,生成8E D8不难理解,在32位模式下,默认的操作数是4字节,由于指令中的源操作数是16位的AX
;所以编译后的机器码前面应该添加0x66前缀以反转默认操作数大小
;由于这一点区别,有前缀的和没有前缀的相比,处理器在执行时会多花一个额外的时钟周期,问题在于这样的指令用得很频繁,而且牵扯到内存段的访问
;因此它们在16位模式和32位模式下的机器指令被设计为相同,都是8E D8,不需要指令前缀
;这可难倒了很多编译器,它们固执地认为在32位模式下,源操作数是16位的寄存器AX时,应该添加指令前缀,为了照顾编译器,程序员习惯使用看起来有点别扭的形式
;       mov ds,eax  ;生成不加指令前缀的8E D8
;NASM编译器还是很优秀的,不会有这样的问题,不管处理器模式如何变化,也不管指令形式如何变化,以下代码编译后的结果都一样
;       [bit 16]
;       mov ds,ax   ;8E D8
;       mov ds,eax   ;8E D8
;
;       [bit 32]
;       mov ds,ax   ;8E D8
;       mov ds,eax   ;8E D8
;因此第7~8行,通过寄存器EAX初始化栈段寄存器SS
;
;                               创建GDT并安装描述符
;准备进入保护模式,首先创建GDT,并安装刚进入保护模式时就要使用的描述符
;第12~15行计算GDT在实模式下的逻辑地址,在11章里,GDT的大小和线性基地址分别是用两个标号gdt_size和gdt_base声明和初始化的
;这里的107行和108行已经改成
;     pgdt             dw 0
;                      dd 0x00007e00      ;GDT的物理地址
;另外一个区别是计算GDT逻辑地址的方法,在32位处理器上,即使是在实模式下,也可以使用32位寄存器,所以第12行直接将GDT的32位线性基地址传送到EAX
;第25~26行,安装保护模式下的数据段描述符,该段线性基地址为0x0000 0000,属于32位的段,段界限0xF FFFF,粒度4KB,对于以4KB为粒度的段,描述符界限加一,就是该段有多少个4KB
;因此实际使用的段界限为 (描述符段界限值+1) X 0x1000 - 1
;将其展开后得到         描述符段界限 X 0x1000 + 0x1000 - 1
;因此实际使用的段界限为  描述符段界限 X 0x1000 + 0xFFF 
;数据段实际使用的段界限是 0xFFFF F X 0x1000 + 0xFFF = 0xFFFF FFFF = 4GB
;第29~30行,安装保护模式下的代码段描述符,该段线性基地址为0x0000 7c00,段界限0x0 01FF,粒度为字节,32位段
;对于向上扩展的段来说,段界限在数值上等于段的长度减去1,该段长度为0x200,512字节,该段实际上就是当前程序所在的段(正在安装该描述符),也就是主引导程序所在的区域
;尽管在描述符中把它定义成32位段,但实际上既包含32位代码也包含16位代码,[bit 32]之前的代码是16位的,之后是32位的,不过在该描述符生效的时候,处理器的执行流已经位于32位代码中了
;第33~34行,安装保护模式下的数据段描述符,该段线性基地址为0x0000 7c00,段界限0x0 01FF,粒度为字节,32位段,和前面的代码段描述符指向的是同一段,用意何在?
;因为在保护模式下,代码段是不可写入的,通过该段的描述符来访问这个区域时,处理器不允许向里面写入或者更改数据,但是很多时候又需要对代码段做一些修改,比如调试程序加入断点指令int3
;不管怎样,如果需要访问代码段内的数据,只能重新安装一个新的描述符,将其定义为可读可写的数据段,当需要修改代码段的内容时,可以通过这个新的描述符来进行
;像这样当两个以上的描述符都描述和指向同一个段时,把另外的描述符称为别名(alias)
;别名技术并非仅仅用于读写代码段,如果两个程序想共享同一内存区域,可以分别为每个程序都创建一个描述符指向同一个段
;第36~37行,安装保护模式下的栈段描述符,该段线性基地址位0x0000 7c00,段界限0xF FFFE,粒度4KB
;尽管该段和代码段使用同一线性基地址,但不会有问题,栈段段向下,代码段向上扩展,下面将会解释栈段段界限与粒度,栈操作时的保护
;第40行,设置GDT的界限值为39,共5个描述符,40字节,界限值39
;                    ~               ~
;                    ~               ~
;                     ---------------
;                    | 基址=0000 7C00 |
;                    | 界限=F FFFE    |     4#
;                    | 粒度=4KB  32   |
;                    | 特权级=00 栈段  |
;           0000 7E20 ---------------
;                    | 基址=0000 7C00 |
;                    | 界限=0 01FF    |     3#
;                    | 粒度=字节  32   |
;                    | 特权级=00 数据段|
;           0000 7E18 ---------------
;                    | 基址=0000 7C00 |
;                    | 界限=0 01FF    |     2#
;                    | 粒度=4KB  32   |
;                    | 特权级=00 代码段|
;           0000 7E10 ---------------
;                    | 基址=0000 0000 |
;                    | 界限=F FFFF    |     1#
;                    | 粒度=4KB  32   |
;                    | 特权级=00 数据段|
;           0000 7E08 ---------------
;                    |               |
;                    |    空描述符    |     0#
;                    |               |
;                    |               |
;           0000 7E00 ---------------
;                    |               |
;                    |               |
;                    ~      MBR      ~
;                    ~               ~
;                    |               |
;                    |               |
;           0000 7C00 ---------------
;                    |               |
;                    |      4KB      |
;                    ~     Stack     ~
;                    ~               ~
;                    |               |
;                    |               |
;           0000 6C00 ---------------
;                    |               |
;                    ~               ~
;                    ~               ~
;
;                               修改段寄存器的保护
;随着程序的执行经常要对段寄存器进行修改,此时处理器在变更段寄存器以及隐藏的描述符高速缓存器的内容时,要检查其代入值的合法性
;第55行是一条直接远转移指令 jmp dword 0x0010:flush             ;16位的描述符选择子：32位偏移
;这条指令会隐式修改段寄存器CS,同样要修改段寄存器的指令还出现在第59~68行
;当这些指令执行时,处理器把指令中给出的段选择子传送到段寄存器的选择器部分,但是处理器的固件在完成传送之前要确认选择子是正确的,并且该选择子选择的描述符也是正确的
;在当前程序中,选择子的TI位都是0,所以所有的描述符都在GDT中,GDT的基地址和界限都在GDTR中,描述符在内存中的地址是用索引号乘以8,再和描述符表的线性基地址相加得到的
;而这个地址必须在描述符表的边界范围之内,换句话说,处理器从GDT中取某个描述符时,要求描述符的8个字节都在GDT边界之内,也就是索引号 X 8 + 7 小于等于边界
;如果检查到指定的描述符,其位置超过表的边界,处理器中止处理产生异常中断13,同时寄存器中的原值保持不变
;
;                                                 ~          ~
;                                                 |          |
;                                                  -------------------------------
;                                                 |          |                   |
;                                                  ----------                   \|/
;    索引号 X 8 + 7 小于等于边界                     |   描述符  |
;                           ---------------->      ----------
;                                   /|\           |          |                  GDT
;                                    |            |          |
;                                    |            |          |
;      --------------------     索引号 X 8         |          |
;     |                    |         |            |          |                  /|\
;     |    _____GDTR_____  |        \|/           |          |                   |
;     |   | 边界 | 基地址-------------------------> ----------------------------------
;     |    --------------  |                      |          |
;     |                    |                      |          |
;     |        CPU         |                      |          |
;     |                    |                      ~          ~
;     |____________________|
;
;以上仅仅是检查的第一步,要是通过上述检查并从表中取得描述符后,紧接着还要对描述符的类别进行确认,举个例子,若描述符的类别是只执行的代码段,则不允许加载到除CS外的其他段寄存器
;具体地说,首先描述符的类别字段必须是有效的值,0000是无效值,然后检查描述符的类别是否和段寄存器的用途匹配,规则如下
;                 数据段(X=0)                      代码段(X=1)
;         只读(W=0)      读写(W=1)        只执行(R=0)      执行可读(R=1)
;   CS      N             N                 Y               Y
;   DS      Y             Y                 N               Y
;   ES      Y             Y                 N               Y
;   FS      Y             Y                 N               Y
;   GS      Y             Y                 N               Y
;   SS      N             Y                 N               N
;可读代码段类似于ROM,可以用段超越前缀cs:来读取其中的内容,也可以将它的描述符选择子加载到ds,es,fs,gs来作为数据段访问,代码段在任何时候都是不可写的
;最后还要检查描述符的P位,如果P=0,表明虽然描述符已经被定义,但是该段实际上并不存在于物理内存中,此时处理器中止处理,引发异常中断11,一般来说应当定义一个中断处理程序
;把该描述符所对应的段从硬盘等外部设备调入内存,然后置P位,中断返回时,处理器再次尝试刚才的操作
;如果P=1,则处理器将描述符加载到段寄存器的描述符高速缓存器,同时置A位(仅限于当前讨论的存储器的段描述符)
;一旦上述规则全部通过,处理器就将选择子加载到段寄存器的选择器,显然只有可以写入的数据段才能加载到SS的选择器,CS寄存器只允许加载代码段描述符
;另外,对于ds,es,fs,gs的选择器来说,可以向其加载数值为0的选择子,尽管加载时不会有什么问题,但是真正要访问内存时,就会导致异常中断,这是一个特殊的设计,处理器用它来保证系统安全
;不过对于cs和ss的选择器来说,不允许向其传送为0的选择子
;第55~68行代码执行完后,cs指向512字节的32位代码段,基地址0x0000 7c00
;ds指向512字节的32位数据段,该段是代码段的别名,基地址也是0x0000 7c00
;es,fs,gs指向同一个段,该段是一个4GB的32位数据段,基地址为0x0000 0000
;ss指向4KB的32位栈段,基地址为0x0000 7c00
;
;                               地址变换时的保护
;代码段执行时的保护
;在32位模式下,尽管段的信息在描述符表中,但是,一旦相应的描述符被加载到段寄存器的描述符高速缓存器,则处理器取指令和执行指令时,将不再访问描述符表
;而是直接使用段寄存器的描述符高速缓存器,从中取得线性基地址,同指令指针寄存器EIP的内容相加共同形成32位的物理地址从内存中取得下一条指令
;不过在指令实际开始执行之前,处理器必须检验其存放地址的有效性,以防止执行超出允许范围之外的指令
;每个代码段都有自己的段界限,位于其描述符中,实际使用的段界限,其数值和粒度有关,G=0,实际的段界限就是描述符中的段界限
;如果G=1,则实际的段界限 = 描述符中的段界限值 X 0x1000 + 0xFFF
;
;代码段是向上扩展的,因此实际使用的段界限值就是当前段内最后一个允许访问的偏移地址,当处理器在该段内取指令时,偏移地址由EIP提供
;指令很有可能是跨越边界的,一部分在边界内,一部分在边界外,或者一条单字节指令正好位于边界上,因此要执行的那条指令,其长度减1后,与EIP的值相加
;结果必须小于等于实际使用的段界限,否则引发处理器异常,即:
;       0 大于等于 (EIP + 指令长度 - 1) 小于等于 实际使用的段界限
;
; 段界限 F |    指令    |
;       D |    指令    |
;eip--->C |    指令    |    eip + 3 -1 = C + 3 - 1 = F
;
;任何指令都不允许也不可能向代码段写入数据,而且只有在代码段可读的情况下(由其描述符指定),才能由指令读其内容
;
;栈操作时的保护
;在保护模式下操作时,栈是比较容易迷惑的问题,截止到目前的所有例子,栈段一直是使用向下扩展的内存段,段界限的检查和向上扩展的数据段和代码段不同
;当然,栈也可以使用向上扩展的段,即把数据段用作栈段,这种情况下,对段界限的检查按数据段的规则进行,但是无论如何栈本身始终是向下增长的,即向低地址推进
;段的扩展方向用于处理器的界限检查,而对栈的性质以及在栈上的操作没有关系,接下去会接触到用向上扩展的段作为栈段的情况
;现在只讨论32位的栈段,描述符B=1,处理器在这样的段上执行压栈和出栈时,默认使用ESP
;和前面讨论过的代码段一样,在栈段中,实际使用的段界限也和粒度位有关,如果G=0,实际使用的段界限就是描述符中记载的段界限
;如果G=1,实际使用的段界限为     描述符段界限 X 0x1000 + 0xFFF
;栈段是向下扩展的,每当往栈中压入数据时,ESP的内容要减去操作数的长度,所以和向高地址方向扩展的段相比,非常重要的一点是,实际使用的段界限就是段内不允许
;注意,是不允许访问的最低端偏移地址,置于最高端的地址,则没有限制,最大可以是0xFFFF FFFF,也就是说,在栈操作时必须符合以下规则:
;       实际使用的段界限 + 1 <= (ESP的内容 - 操作数的长度) <= 0xFFFF FFFF
;上一章里,栈段的粒度是字节,描述符的段界限是0x07A00,此时实际使用的段界限也是0x07A00,假设现在的esp=0x0000 7A04,那么执行下面的指令
;       push edx
;因为是要压入一个双字,4字节,所以处理器在向栈中写入数据之前,先将ESP减去4,得到0x7A00,这就是ESP寄存器在进行压栈操作时的新值,因为该值小于实际使用的段界限0x7A00加1(0x7A01)
;因此不允许执行该操作,0x7A00就不允许访问了,但是如果执行下面的指令
;       push ax
;因为要压入一个字,2字节,所以实际执行压栈操作时,ESP的内容是
;   0x7C04 - 2 = 0x7C02
;结果大于实际使用的段界限加1,允许操作
;回到代码第67~69行,这三行设置栈的线性基地址为0x0000 7C00,段界限为0xF FFFE,粒度4KB,并设置esp=0
;实际使用的段界限为 0xF FFFE X 0x1000 + 0xFFF = 0xFFFF eFFF
;又因为ESP的最大值为0xFFFF FFFF,因此如下图所示,在操作该段时,处理器的检查规则是:
;       0xFFFF F000 <= (ESP - 操作数的长度) <= 0xFFFF FFFF
;                                                       ~            ~
;                                                       ~            ~
;                                                       |            |
;       偏移地址=FFFF FFFF,高端有效物理地址=0000 7BFF------> ------------
;                 /|\                                   |            |
;                  |                                    |            |
;                  |                                    |            |
;                                                       |            |
;                                                       |    栈段     |
;             ESP + 操作数大小                            |            |
;                                                       |            |
;                  |                                    |            |
;                  |                                    |            |
;                 \|/                                   |            |
;       偏移地址=FFFF F000,低端有效物理地址=0000 6C00------> ------------
;                                                       |            |
;                                                       |            |
;                                                       ~            ~
;                                                       ~            ~
;栈指针寄存器ESP的内容仅仅在访问栈时提供偏移地址,操作数在压入栈时的物理地址要用段寄存器的描述符高速缓存器中的段基地址和ESP相加得到,因此该栈最低端有效物理地址是
;       0x0000 7c00 + 0xFFFF F000 = 0x0000 6C00
;最高端有效物理地址
;       0x0000 7c00 + 0xFFFF FFFF = 0x0000 7BFF
;也就是说当前程序所定义的栈段空间介于0x0000 6C00 ~ 0x0000 7BFF之间,大小4KB
;结合现在该栈段,用一个实例来说明处理器的检查过程,第69行将esp的初始值设定为0,因此,当第一次压栈时,加入压入一个双字,4字节
;       push ecx
;因为压栈操作先是减esp,然后在访问栈,故esp的新值是0 - 4 =0xFFFF FFFC
;这个结果符合上面的限制条件,允许操作,此时被压入的那个双字,线性地址为
;       0x0000 7C00 + 0xFFFF FFFC = 0x0000 7BFC
;
;   7C00|  不可用 |
;   7BFF|   ecx  |
;   7BFE|   ecx  |
;   7BFD|   ecx  |
;   7BFC|   ecx  |<---新的栈指针将指向这里,刚好4字节
;       ~        ~
;       ~        ~
;       |        |
;       |        |
;       |        |
;   6C00|        |
;   6BFF|  不可用 |
;
;
;数据访问时的保护
;这里所说的数据段特指向上扩展的数据段,有别于栈段和向下扩展的数据段,因为是向上扩展的,所以代码段的检查规则同样适用于数据段,不同之处仅仅在于
;对于取指令来说,是否越界取决于指令的长度,而对于数据段来说则取决于操作数的尺寸,考虑下面指令:
;       mov [0x2000],edx
;这条指令将访问内存,并将edx寄存器的内容写入当前段内偏移量为0x2000的双字单元,32位的edx
;指令中给出了内存单元的有效地址EA(0x2000),也给出了操作数的大小4,处理器访问数据段时,要依据下列规则进行检查
;       0 <= (EA + 操作数大小 - 1) <= 实际使用的段界限
;在任何时候,段界限之外的访问都会被阻止,并引发处理器异常中断
;在32位处理器上,尽管段界限的检查总在进行,但是如果段界限具有最大值,则对任何内存地址的访问都将不会违例,比如本章定义了一个具有4GB长的段,段的基地址是0x0000 0000
;段界限是0xF FFFF,粒度4KB,因此实际使用的段界限是    0xF FFFF X 0x1000 + 0xFFF = 0xFFFF FFFF
;在这样的段内,访问任何一个内存单元都是允许的
;在32位模式下,处理器使用32位的段基地址加上32位的偏移量,共同形成32位的物理地址来访问内存,段基地址由段描述符指定,而偏移量由指令直接给出或间接给出,很显然在段最大的时候可以访问任何内存
;第71~74行,从物理地址0x000B 8000开始写入16字节内容,用于演示4GB内存空间的访问,段寄存器ES当前正指向0到4GB的空间,其描述符高速缓存器中的基地址为0x0000 0000
;加上指令中提供的32位偏移量,所访问的地方正是显示缓冲区所在的区域
;
;                               使用别名访问代码段对字符排序
;接下来要做的事情是对一串字符串进行排序,演示如何在保护模式下使用别名段,字符串位于第105行,属于引导程序的一部分,在进入保护模式时,它就位于32位代码段中
;代码段是用来执行的,能不能读出,取决于其描述符的类别字段,但是无论如何都不允许写入,这就有点难办,我们想就地将这串字符串按ASCII码从小到大排序,涉及到原地写入数据的操作
;好在前面已经建立了代码段的别名描述符,而且用段寄存器DS指向了它
;冒泡排序是比较容易理解的排序算法,但却不是效率最高的,如果字符串的长度是n个,而且要从小到达排序,可以将它们从头至尾两两比较,需要比较n-1次,这一次遍历只会让最大的字符移动到右边
;所以需要n-1次这样的遍历,可见这需要两个循环,一个外循环,用于控制遍历次数,一个内循环,用于控制每次遍历时的比较次数,在32位模式下,loop指令所用的计数器是ecx
;并且两个循环共用ecx,这点需要技巧,就是利用栈:
;
;       mov ecx,n-1
;external:
;       xor ebx,ebx
;       push ecx
;
;internal:
;       ...             ;对字符串两两比较
;       inc ebx
;       loop internal
;
;       pop ecx
;       loop external
;
;外循环总共执行n-1次,每执行一次外循环,内循环就会将一个数排到正确的位置,从而使下一次内循环少一次两两对比
;也就是说exc寄存器的当前值总是内循环的次数,这就是为什么内循环的loop指令要使用外循环的ecx值
;需要注意的是:
;   在32位模式下,如果指令的操作数是16位,要加前缀0x66,相似地,在32位模式下,如果要在指令中使用16位的有效地址,那么必须为该指令添加前缀0x67
;因此当前指令
;       mov eax,[bx]
;用bit 32编译后,会有指令前缀0x67,在32位模式下执行时,处理器会用数据段描述符中给出的32位数据段基地址,加上bx寄存器中的16位偏移量,形成32位线性地址